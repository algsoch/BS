[
    {
        "file": "E://data science tool//GA1//first.py",
        "question": null,
        "parameter": null,
        "code": "import subprocess\n\n# Install and run Visual Studio Code. In your Terminal (or Command Prompt), type code -s and press Enter. Copy and paste the entire output below.\n\n# What is the output of code -s?\ndef get_vscode_status():\n    try:\n        result = subprocess.run('code -s', shell=True, capture_output=True, text=True)\n        return result.stdout\n    except FileNotFoundError:\n        return \"Visual Studio Code is not installed or not added to PATH.\"\n\noutput = get_vscode_status()\nprint(output)"
    },
    {
        "file": "E://data science tool//GA1//second.py",
        "question": null,
        "parameter": null,
        "code": "import requests\nimport json\ndef send_request(url, params):\n    response = requests.get(url, params=params)\n    print(json.dumps(response.json(), indent=4))\n\nurl = \"https://httpbin.org/get\"\nparams = {\"email\": \"24f2006438@ds.study.iitm.ac.in\"}\nsend_request(url, params)"
    },
    {
        "file": "E://data science tool//GA1//third.py",
        "question": null,
        "parameter": null,
        "code": "import subprocess\n\n'''Let's make sure you know how to use npx and prettier.\n\nDownload README.md. In the directory where you downloaded it, make sure it is called README.md, and run npx -y prettier@3.4.2 README.md | sha256sum.\n\nWhat is the output of the command?'''\ndef run_command():\n    import hashlib\n    result = subprocess.run(\"npx -y prettier@3.4.2 README.md | sha256sum\", capture_output=True, text=True, shell=True)\n    formatted_output = result.stdout\n    sha256_hash = hashlib.sha256(formatted_output.encode()).hexdigest()\n    print(sha256_hash)\n\nif __name__ == '__main__':\n    run_command()"
    },
    {
        "file": "E://data science tool//GA1//fourth.py",
        "question": null,
        "parameter": null,
        "code": null
    },
    {
        "file": "E://data science tool//GA1//fifth.py",
        "question": null,
        "parameter": null,
        "code": null
    },
    {
        "file": "E://data science tool//GA1//sixth.py",
        "question": null,
        "parameter": null,
        "code": null
    },
    {
        "file": "E://data science tool//GA1//seventh.py",
        "question": null,
        "parameter": null,
        "code": "import datetime\n\n# How many Wednesdays are there in the date range 1981-03-03 to 2012-12-30?'''\n\ndef count_specific_day_in_range(day_of_week, start_date, end_date):\n    \"\"\"\n    Count occurrences of a specific day within a given date range.\n    \n    Accepts flexible input for the day:\n      - Integer 1 to 7 (Monday=1, ..., Sunday=7) or 0 to 6 (Monday=0, ..., Sunday=6)\n      - Full day name (e.g., \"Wednesday\") in any case\n    Count occurrences of a specific day within a given date range.\n    \n    Accepts flexible input for the day:\n      - Integer 1 to 7 (Monday=1, ..., Sunday=7) or 0 to 6 (Monday=0, ..., Sunday=6)\n      - Full day name (e.g., \"Wednesday\") in any case\n    \n    Parameters:\n      day_of_week (int or str): The target day (e.g., 2 or \"Wednesday\")\n      start_date (datetime.date): The starting date\n      end_date (datetime.date): The ending date\n      \n    Returns:\n      int: Number of times the target day appears in the range\n    \"\"\"\n    # Convert day_of_week to Python's weekday format (Monday=0, ..., Sunday=6)\n    if isinstance(day_of_week, int):\n        if 1 <= day_of_week <= 7:\n            target_day = day_of_week - 1\n        elif 0 <= day_of_week <= 6:\n            target_day = day_of_week\n        else:\n            raise ValueError(\"Integer day must be in the range 0-6 or 1-7.\")\n    elif isinstance(day_of_week, str):\n        day_map = {\n            \"monday\": 0,\n            \"tuesday\": 1,\n            \"wednesday\": 2,\n            \"thursday\": 3,\n            \"friday\": 4,\n            \"saturday\": 5,\n            \"sunday\": 6\n        }\n        key = day_of_week.strip().lower()\n        if key in day_map:\n            target_day = day_map[key]\n        else:\n            raise ValueError(\"Invalid day name. Use full day names like 'Monday'.\")\n    else:\n        raise TypeError(\"day_of_week must be an int or str.\")\n    \n    count = 0\n    current_date = start_date\n    while current_date <= end_date:\n        if current_date.weekday() == target_day:\n            count += 1\n        current_date += datetime.timedelta(days=1)\n    return count\n\nif __name__ == \"__main__\":\n    # Define parameters\n    start = datetime.date(1981, 3, 3)\n    end = datetime.date(2012, 12, 30)\n    # Wednesday is represented as 2 (Monday=0, Tuesday=1, Wednesday=2, ...)\n    target_day = input(\"Enter the day of week (e.g., 2 for Wednesday or 'Wednesday'): \")  \n\n    # Count the number of Wednesdays in the provided date range\n    wednesdays_count = count_specific_day_in_range(target_day, start, end)\n    # def solve(question):\n    #     pass\n        \n    print(\"Number of Wednesdays:\", wednesdays_count)"
    },
    {
        "file": "E://data science tool//GA1//eighth.py",
        "question": null,
        "parameter": null,
        "code": "import csv\nimport zipfile\nimport io\n\n# file name is q-extract-csv-zip.zip and unzip file  which has a single extract.csv file inside.\n\n# What is the value in the \"answer\" column of the CSV file?\ndef extract_answer(zip_file, row_index=0, column='answer'):\n    try:\n        with zipfile.ZipFile(zip_file, 'r') as z:\n            file_list = z.namelist()\n            if not file_list:\n                print(\"Error: Zip file is empty.\")\n                return\n            if len(file_list) > 1:\n                print(\"Warning: More than one file found in the zip. Using the first file:\", file_list[0])\n            target_file = file_list[0]\n            \n            with z.open(target_file) as f:\n                file_io = io.TextIOWrapper(f, encoding='utf-8')\n                reader = csv.DictReader(file_io)\n                for i, row in enumerate(reader):\n                    if i == row_index:\n                        if column in row:\n                            print(row[column])\n                        else:\n                            print(f\"Error: Column '{column}' not found in CSV file.\")\n                        return\n                print(\"Error: CSV file does not have the specified row index.\")\n    except FileNotFoundError:\n        print(\"Error: Zip file not found.\")\n    except zipfile.BadZipFile:\n        print(\"Error: Provided file is not a valid zip file.\")\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n\n# Example usage:\nextract_answer('GA1/q-extract-csv-zip.zip')"
    },
    {
        "file": "E://data science tool//GA1//ninth.py",
        "question": null,
        "parameter": null,
        "code": "import json\n\n# Let's make sure you know how to use JSON. Sort this JSON array of objects by the value of the age field. In case of a tie, sort by the name field. Paste the resulting JSON below without any spaces or newlines.\n\n# [{\"name\":\"Alice\",\"age\":0},{\"name\":\"Bob\",\"age\":16},{\"name\":\"Charlie\",\"age\":23},{\"name\":\"David\",\"age\":32},{\"name\":\"Emma\",\"age\":95},{\"name\":\"Frank\",\"age\":25},{\"name\":\"Grace\",\"age\":36},{\"name\":\"Henry\",\"age\":71},{\"name\":\"Ivy\",\"age\":15},{\"name\":\"Jack\",\"age\":55},{\"name\":\"Karen\",\"age\":9},{\"name\":\"Liam\",\"age\":53},{\"name\":\"Mary\",\"age\":43},{\"name\":\"Nora\",\"age\":11},{\"name\":\"Oscar\",\"age\":40},{\"name\":\"Paul\",\"age\":73}]\ndef sort_json_objects(data_list):\n    return sorted(data_list, key=lambda obj: (obj[\"age\"], obj[\"name\"]))\n\ndata = [{\"name\":\"Alice\",\"age\":0},{\"name\":\"Bob\",\"age\":16},{\"name\":\"Charlie\",\"age\":23},{\"name\":\"David\",\"age\":32},{\"name\":\"Emma\",\"age\":95},{\"name\":\"Frank\",\"age\":25},{\"name\":\"Grace\",\"age\":36},{\"name\":\"Henry\",\"age\":71},{\"name\":\"Ivy\",\"age\":15},{\"name\":\"Jack\",\"age\":55},{\"name\":\"Karen\",\"age\":9},{\"name\":\"Liam\",\"age\":53},{\"name\":\"Mary\",\"age\":43},{\"name\":\"Nora\",\"age\":11},{\"name\":\"Oscar\",\"age\":40},{\"name\":\"Paul\",\"age\":73}]\n\nsorted_data = sort_json_objects(data)\nprint(json.dumps(sorted_data, separators=(\",\",\":\")))"
    },
    {
        "file": "E://data science tool//GA1//tenth.py",
        "question": null,
        "parameter": null,
        "code": "import sys\nimport json\nimport requests\nimport os\nimport time\nfrom selenium import webdriver\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.chrome.service import Service\nfrom selenium.webdriver.chrome.options import Options\nfrom webdriver_manager.chrome import ChromeDriverManager\n\n# def create_sample_file(filename):\n#     \"\"\"Create a sample file with key=value pairs\"\"\"\n#     content = \"\"\"# This is a sample file\n# name=John Doe\n# age=30\n# city=New York\n# occupation=Developer\n# skill=Python\n# experience=5 years\n# # End of file\"\"\"\n    \n#     with open(filename, 'w') as f:\n#         f.write(content)\n#     print(f\"Created sample file: {filename}\")\n\ndef convert_file(filename):\n    \"\"\"Convert key=value pairs from file into a JSON object\"\"\"\n    data = {}\n    with open(filename, 'r') as f:\n        for line in f:\n            line = line.strip()\n            if not line or line.startswith('#'):\n                continue\n            if '=' in line:\n                key, value = line.split('=', 1)\n                data[key.strip()] = value.strip()\n    return data\n\ndef get_json_hash_using_web_interface(json_data):\n    \"\"\"Get hash by simulating manual entry on the website\"\"\"\n    import os\n    import sys\n    from contextlib import contextmanager\n    \n    @contextmanager\n    def suppress_stdout_stderr():\n        \"\"\"Context manager to suppress stdout and stderr.\"\"\"\n        # Save original stdout/stderr\n        old_stdout, old_stderr = sys.stdout, sys.stderr\n        null = open(os.devnull, \"w\")\n        try:\n            sys.stdout, sys.stderr = null, null\n            yield\n        finally:\n            # Restore original stdout/stderr\n            sys.stdout, sys.stderr = old_stdout, old_stderr\n            null.close()\n    \n    json_str = json.dumps(json_data, separators=(',', ':'))\n    \n    # Setup Chrome options\n    chrome_options = Options()\n    chrome_options.add_argument(\"--headless\")\n    chrome_options.add_argument(\"--log-level=3\")\n    chrome_options.add_experimental_option('excludeSwitches', ['enable-logging'])\n    \n    try:\n        # Initialize the driver with suppressed output\n        with suppress_stdout_stderr():\n            driver = webdriver.Chrome(service=Service(ChromeDriverManager().install()), options=chrome_options)\n            \n            # Navigate to the page\n            driver.get(\"https://tools-in-data-science.pages.dev/jsonhash\")\n            \n            # Find the textarea and put our JSON in it\n            textarea = driver.find_element(By.CSS_SELECTOR, \"textarea[name='json']\")\n            textarea.clear()\n            textarea.send_keys(json_str)\n            \n            # Click the hash button\n            hash_button = driver.find_element(By.CSS_SELECTOR, \"button.btn-success\")\n            hash_button.click()\n            \n            # Wait for result to load\n            time.sleep(2)\n            \n            # Get the result from the result field\n            hash_result = driver.find_element(By.ID, \"result\").get_attribute(\"value\")\n            \n            # Close the browser\n            driver.quit()\n        \n        return hash_result\n    except Exception as e:\n        return f\"Error using web interface: {str(e)}\"\n\nif __name__ == \"__main__\":\n    # Redirect stderr to suppress ChromeDriver messages\n    import sys\n    from io import StringIO\n    \n    original_stderr = sys.stderr\n    sys.stderr = StringIO()  # Redirect stderr to a string buffer\n    \n    filename = \"q-multi-cursor-json.txt\"\n    \n    # Create the sample file if it doesn't exist\n    if not os.path.exists(filename):\n        create_sample_file(filename)\n    \n    # Convert file to JSON\n    result = convert_file(filename)\n    \n    # Output JSON without spaces\n    json_output = json.dumps(result, separators=(',', ':'))\n    # print(\"\\nJSON Output:\")\n    # print(json_output)\n    \n    # Get hash using the web interface\n    hash_result = get_json_hash_using_web_interface(result)\n    print(f\"{hash_result}\")\n    \n    # Restore stderr\n    sys.stderr = original_stderr"
    },
    {
        "file": "E://data science tool//GA1//eleventh.py",
        "question": null,
        "parameter": null,
        "code": null
    },
    {
        "file": "E://data science tool//GA1//twelfth.py",
        "question": null,
        "parameter": null,
        "code": "import argparse\nimport csv\nimport io\nimport zipfile\nimport os\nimport tempfile\nimport shutil\nimport codecs\n\ndef process_unicode_data(zip_file_path=None):\n    # Use default zip name if none provided\n    if not zip_file_path:\n        zip_file_path = \"q-unicode-data.zip\"\n    \n    # Try different locations for the zip file\n    if not os.path.exists(zip_file_path):\n        script_dir = os.path.dirname(os.path.abspath(__file__))\n        zip_path = os.path.join(script_dir, zip_file_path)\n        if os.path.exists(zip_path):\n            zip_file_path = zip_path\n        else:\n            return f\"Error: Zip file '{zip_file_path}' not found\"\n\n    target_symbols = {\"\u0153\", \"\u017d\", \"\u0178\"}\n    file_details = {\n        \"data1.csv\": {\"encoding\": \"cp1252\", \"delimiter\": \",\"},\n        \"data2.csv\": {\"encoding\": \"utf-8\", \"delimiter\": \",\"},\n        \"data3.txt\": {\"encoding\": \"utf-16\", \"delimiter\": \"\\t\"}\n    }\n\n    total = 0.0\n    tmp_dir = tempfile.mkdtemp()\n    \n    try:\n        # Extract the zip file\n        with zipfile.ZipFile(zip_file_path, 'r') as z:\n            z.extractall(tmp_dir)\n        \n        # Process each file\n        for filename, file_info in file_details.items():\n            file_path = os.path.join(tmp_dir, filename)\n            if not os.path.exists(file_path):\n                continue\n            \n            # Handle UTF-16 files\n            if file_info[\"encoding\"].lower() == \"utf-16\":\n                with open(file_path, 'rb') as f_bin:\n                    raw_data = f_bin.read()\n                    # Remove BOM if present\n                    if raw_data.startswith(codecs.BOM_UTF16_LE):\n                        raw_data = raw_data[2:]\n                    elif raw_data.startswith(codecs.BOM_UTF16_BE):\n                        raw_data = raw_data[2:]\n                    \n                    content = raw_data.decode('utf-16')\n                    reader = csv.reader(io.StringIO(content), delimiter=file_info[\"delimiter\"])\n                    \n                    for row in reader:\n                        if len(row) >= 2 and row[0].strip() in target_symbols:\n                            try:\n                                total += float(row[1].strip())\n                            except ValueError:\n                                pass\n            # Handle other encodings\n            else:\n                with open(file_path, 'r', encoding=file_info[\"encoding\"]) as f:\n                    reader = csv.reader(f, delimiter=file_info[\"delimiter\"])\n                    \n                    for row in reader:\n                        if len(row) >= 2 and row[0].strip() in target_symbols:\n                            try:\n                                total += float(row[1].strip())\n                            except ValueError:\n                                pass\n    \n    except Exception as e:\n        return f\"Error: {str(e)}\"\n    \n    finally:\n        # Clean up\n        shutil.rmtree(tmp_dir)\n    \n    # Just return the total as an integer if it's a whole number\n    if total.is_integer():\n        return int(total)\n    return total\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser(description=\"Process unicode data from zip file\")\n    parser.add_argument(\"zip_file\", nargs=\"?\", help=\"Path to the zip file (default: q-unicode-data.zip)\")\n    args = parser.parse_args()\n    \n    result = process_unicode_data(args.zip_file)\n    print(result)"
    },
    {
        "file": "E://data science tool//GA1//thirteenth.py",
        "question": null,
        "parameter": null,
        "code": "import os\nimport json\nimport urllib.request\nimport urllib.error\nimport base64\nimport getpass\nimport time\nimport datetime\nfrom dotenv import load_dotenv\n\ndef load_env_file():\n    \"\"\"Load environment variables from .env file\"\"\"\n    env_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), '.env')\n    \n    if not os.path.exists(env_path):\n        # Try looking in parent directory\n        env_path = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), '.env')\n        if not os.path.exists(env_path):\n            return False\n    \n    # Parse .env file\n    env_vars = {}\n    with open(env_path, 'r') as file:\n        for line in file:\n            line = line.strip()\n            if not line or line.startswith('#'):\n                continue\n            key, value = line.split('=', 1)\n            env_vars[key.strip()] = value.strip().strip('\"\\'')\n    \n    # Set environment variables\n    for key, value in env_vars.items():\n        os.environ[key] = value\n    \n    return True\n\ndef check_repo_exists(username, repo_name, token):\n    \"\"\"Check if a repository already exists\"\"\"\n    headers = {\n        \"Authorization\": f\"token {token}\",\n        \"Accept\": \"application/vnd.github.v3+json\"\n    }\n    \n    try:\n        req = urllib.request.Request(\n            f\"https://api.github.com/repos/{username}/{repo_name}\",\n            headers=headers\n        )\n        with urllib.request.urlopen(req) as response:\n            # If we get a successful response, the repo exists\n            return True\n    except urllib.error.HTTPError as e:\n        if e.code == 404:\n            # 404 means repo doesn't exist\n            return False\n        else:\n            # Some other error\n            raise\n    except Exception:\n        raise\n\ndef create_github_repo_with_token(token):\n    username = \"algsoch\"  # Replace with your actual username\n    base_repo_name = \"email-repo\"\n    \n    # Check if repo exists and generate unique name if needed\n    repo_name = base_repo_name\n    try:\n        if check_repo_exists(username, repo_name, token):\n            # Repository exists, generate a unique name\n            timestamp = datetime.datetime.now().strftime(\"%Y%m%d%H%M%S\")\n            repo_name = f\"{base_repo_name}-{timestamp}\"\n    except Exception:\n        pass\n    \n    email_data = {\n        \"email\": \"24f2006438@ds.study.iitm.ac.in\"\n    }\n    \n    # Create repository\n    create_repo_url = \"https://api.github.com/user/repos\"\n    repo_data = {\n        \"name\": repo_name,\n        \"description\": \"Repository with email.json\",\n        \"private\": False,\n        \"auto_init\": True\n    }\n    \n    headers = {\n        \"Authorization\": f\"token {token}\",\n        \"Accept\": \"application/vnd.github.v3+json\"\n    }\n    \n    try:\n        # Create repo\n        req = urllib.request.Request(\n            create_repo_url,\n            data=json.dumps(repo_data).encode(),\n            headers=headers,\n            method=\"POST\"\n        )\n        \n        with urllib.request.urlopen(req) as response:\n            repo_info = json.loads(response.read().decode())\n            \n        # Add file (wait a moment for repository initialization)\n        time.sleep(3)  # Extended wait time to ensure repo is initialized\n        \n        # Create file content\n        file_content = json.dumps(email_data, indent=2)\n        content_encoded = base64.b64encode(file_content.encode()).decode()\n        \n        create_file_url = f\"https://api.github.com/repos/{username}/{repo_name}/contents/email.json\"\n        file_data = {\n            \"message\": \"Add email.json\",\n            \"content\": content_encoded,\n            \"branch\": \"main\"\n        }\n        \n        req = urllib.request.Request(\n            create_file_url,\n            data=json.dumps(file_data).encode(),\n            headers=headers,\n            method=\"PUT\"\n        )\n        \n        with urllib.request.urlopen(req) as response:\n            file_info = json.loads(response.read().decode())\n            \n        raw_url = f\"https://raw.githubusercontent.com/{username}/{repo_name}/main/email.json\"\n        print(raw_url)\n        return True\n        \n    except urllib.error.HTTPError as e:\n        error_message = e.read().decode()\n        \n        # If error is that repo already exists, try with a unique name\n        if e.code == 422 and \"already exists\" in error_message:\n            timestamp = datetime.datetime.now().strftime(\"%Y%m%d%H%M%S\")\n            new_repo_name = f\"{repo_name}-{timestamp}\"\n            \n            # Modify repo_data with new name and try again\n            repo_data[\"name\"] = new_repo_name\n            return create_github_repo_with_token(token)  # Recursive call with new name\n        \n        return False\n    except Exception:\n        return False\n\ndef create_github_repo():\n    # First try to load from .env file\n    load_env_file()\n    \n    # Try both potential environment variable names\n    token = os.getenv(\"GITHUB_TOKEN\") or os.getenv(\"GITHUB_API_KEY\")\n    if not token:\n        token = getpass.getpass(\"Token (input will be hidden): \")\n        if not token:\n            return False\n    \n    return create_github_repo_with_token(token)\n\nif __name__ == \"__main__\":\n    # Suppress all stderr output to hide any warnings/errors\n    import sys\n    original_stderr = sys.stderr\n    sys.stderr = open(os.devnull, 'w')\n    \n    try:\n        create_github_repo()\n    finally:\n        # Restore stderr\n        sys.stderr.close()\n        sys.stderr = original_stderr"
    },
    {
        "file": "E://data science tool//GA1//fourteenth.py",
        "question": null,
        "parameter": null,
        "code": "import sys\nimport os\nimport re\nimport zipfile\nimport hashlib\n\ndef process_zip(zip_path=\"q-replace-across-files.zip\"):\n    # Get absolute path to the zip file\n    if not os.path.isabs(zip_path):\n        script_dir = os.path.dirname(os.path.abspath(__file__))\n        zip_path = os.path.join(script_dir, zip_path)\n    \n    # Create extraction folder name\n    extract_folder = os.path.splitext(os.path.basename(zip_path))[0] + \"_extracted\"\n    \n    # Remove folder if it already exists\n    if os.path.exists(extract_folder):\n        import shutil\n        shutil.rmtree(extract_folder)\n    \n    # print(f\"Extracting {zip_path} to {extract_folder}\")\n    \n    # Extract zip file\n    with zipfile.ZipFile(zip_path, 'r') as z:\n        z.extractall(extract_folder)\n    \n    # Compile regex pattern for case-insensitive 'iitm'\n    pattern = re.compile(b'iitm', re.IGNORECASE)\n    replacement = b'IIT Madras'\n    \n    # Replace text in all files\n    modified_count = 0\n    for name in sorted(os.listdir(extract_folder)):\n        file_path = os.path.join(extract_folder, name)\n        if os.path.isfile(file_path):\n            with open(file_path, 'rb') as f:\n                content = f.read()\n            \n            new_content = pattern.sub(replacement, content)\n            \n            if content != new_content:\n                modified_count += 1\n                with open(file_path, 'wb') as f:\n                    f.write(new_content)\n    \n    # print(f\"Modified {modified_count} files\")\n    \n    # Calculate SHA-256 hash of all files in sorted order (equivalent to cat * | sha256sum)\n    sha256 = hashlib.sha256()\n    for name in sorted(os.listdir(extract_folder)):\n        file_path = os.path.join(extract_folder, name)\n        if os.path.isfile(file_path):\n            with open(file_path, 'rb') as f:\n                sha256.update(f.read())\n    \n    hash_result = sha256.hexdigest()\n    # print(f\"SHA-256 hash: {hash_result}\")\n    return hash_result\n\nif __name__ == \"__main__\":\n    zip_path = sys.argv[1] if len(sys.argv) > 1 else \"q-replace-across-files.zip\"\n    hash_result = process_zip(zip_path)\n    print(hash_result)"
    },
    {
        "file": "E://data science tool//GA1//fifteenth.py",
        "question": null,
        "parameter": null,
        "code": "import os\nimport zipfile\nimport datetime\nimport time\nimport sys\n\ndef extract_zip_preserving_timestamps(zip_file, extract_dir=None):\n    \"\"\"Extract a zip file while preserving file timestamps\"\"\"\n    if extract_dir is None:\n        extract_dir = os.path.splitext(zip_file)[0] + \"_extracted\"\n    \n    if not os.path.exists(extract_dir):\n        os.makedirs(extract_dir)\n        \n    with zipfile.ZipFile(zip_file, 'r') as zip_ref:\n        zip_ref.extractall(extract_dir)\n        \n        # Set timestamps from zip info\n        for info in zip_ref.infolist():\n            if info.filename[-1] == '/':  # Skip directories\n                continue\n                \n            # Get file path in extraction directory\n            file_path = os.path.join(extract_dir, info.filename)\n            \n            # Convert DOS timestamp to Unix timestamp\n            date_time = info.date_time\n            timestamp = time.mktime((\n                date_time[0], date_time[1], date_time[2],\n                date_time[3], date_time[4], date_time[5],\n                0, 0, -1\n            ))\n            \n            # Set file modification time\n            os.utime(file_path, (timestamp, timestamp))\n    \n    return extract_dir\n\ndef list_files_with_attributes(directory):\n    \"\"\"List all files with their sizes and timestamps (similar to ls -l)\"\"\"\n    files_info = []\n    total_size = 0\n    \n    for filename in os.listdir(directory):\n        file_path = os.path.join(directory, filename)\n        \n        if os.path.isfile(file_path):\n            file_size = os.path.getsize(file_path)\n            mod_time = datetime.datetime.fromtimestamp(os.path.getmtime(file_path))\n            total_size += file_size\n            \n            files_info.append({\n                'name': filename,\n                'size': file_size,\n                'modified': mod_time,\n                'path': file_path\n            })\n    \n    # Sort files by name\n    files_info.sort(key=lambda x: x['name'])\n    \n    # Print file information\n    # print(f\"Found {len(files_info)} files, total size: {total_size} bytes\")\n    # print(\"\\nFile Listing:\")\n    # print(\"{:<20} {:>10} {:<20}\".format(\"Modified\", \"Size\", \"Filename\"))\n    # print(\"-\" * 60)\n    \n    for file_info in files_info:\n        # print(\"{:<20} {:>10} {:<20}\".format(\n        #     file_info['modified'].strftime('%Y-%m-%d %H:%M:%S'),\n        #     file_info['size'],\n        #     file_info['name']\n        # ))\n        pass\n    \n    return files_info\n\ndef calculate_total_size_filtered(files_info, min_size, min_date):\n    \"\"\"Calculate total size of files matching criteria\"\"\"\n    total_size = 0\n    matching_files = []\n    \n    for file_info in files_info:\n        if (file_info['size'] >= min_size and file_info['modified'] >= min_date):\n            total_size += file_info['size']\n            matching_files.append(file_info)\n    \n    # Print matching files\n    if matching_files:\n        # print(\"\\nFiles matching criteria (size \u2265 {}, date \u2265 {}):\"\n            #   .format(min_size, min_date.strftime('%Y-%m-%d %H:%M:%S')))\n        # print(\"{:<20} {:>10} {:<20}\".format(\"Modified\", \"Size\", \"Filename\"))\n        # print(\"-\" * 60)\n        \n        for file_info in matching_files:\n            # print(\"{:<20} {:>10} {:<20}\".format(\n            #     file_info['modified'].strftime('%Y-%m-%d %H:%M:%S'),\n            #     file_info['size'],\n            #     file_info['name']\n            # ))\n            pass\n    \n    return total_size, matching_files\n\ndef main():\n    # Get zip file path\n    if len(sys.argv) > 1:\n        zip_file = sys.argv[1]\n    else:\n        script_dir = os.path.dirname(os.path.abspath(__file__))\n        zip_file = os.path.join(script_dir, \"q-list-files-attributes.zip\")\n    \n    # Extract zip while preserving timestamps\n    extract_dir = extract_zip_preserving_timestamps(zip_file)\n    # print(f\"Extracted files to: {extract_dir}\")\n    \n    # List all files with attributes\n    files_info = list_files_with_attributes(extract_dir)\n    \n    # Set the minimum date (Oct 31, 2010, 9:43 AM IST)\n    # Convert to local time zone\n    ist_offset = 5.5 * 3600  # IST is UTC+5:30\n    local_tz_offset = -time.timezone  # Local timezone offset in seconds\n    adjustment = ist_offset - local_tz_offset\n    \n    min_timestamp = datetime.datetime(2010, 10, 31, 9, 43, 0)\n    min_timestamp = min_timestamp - datetime.timedelta(seconds=adjustment)\n    \n    # Calculate total size of files meeting criteria\n    total_size, matching_files = calculate_total_size_filtered(\n        files_info, 4675, min_timestamp)\n    \n    # print(f\"\\nTotal size of files meeting criteria: {total_size} bytes\")\n    \n    return total_size\n\nif __name__ == \"__main__\":\n    result = main()\n    # print(f'Answer: {result}')\n    print(f\"{result}\")"
    },
    {
        "file": "E://data science tool//GA1//sixteenth.py",
        "question": null,
        "parameter": null,
        "code": "import os\nimport zipfile\nimport re\nimport hashlib\nimport shutil\nimport sys\nfrom pathlib import Path\n\ndef extract_zip(zip_path, extract_dir=None):\n    \"\"\"Extract a zip file to the specified directory\"\"\"\n    if extract_dir is None:\n        extract_dir = Path(zip_path).stem + \"_extracted\"\n    \n    # Create extraction directory if it doesn't exist\n    os.makedirs(extract_dir, exist_ok=True)\n    \n    # Extract the zip file\n    with zipfile.ZipFile(zip_path, 'r') as zip_ref:\n        zip_ref.extractall(extract_dir)\n    \n    return extract_dir\n\ndef move_files_to_flat_folder(source_dir, dest_dir=None):\n    \"\"\"Move all files from source_dir (including subdirectories) to dest_dir\"\"\"\n    if dest_dir is None:\n        dest_dir = os.path.join(source_dir, \"flat_files\")\n    \n    # Create destination directory if it doesn't exist\n    os.makedirs(dest_dir, exist_ok=True)\n    \n    # Walk through all directories and files\n    for root, dirs, files in os.walk(source_dir):\n        # Skip the destination directory itself\n        if os.path.abspath(root) == os.path.abspath(dest_dir):\n            continue\n        \n        # Move each file to the destination directory\n        for file in files:\n            source_path = os.path.join(root, file)\n            dest_path = os.path.join(dest_dir, file)\n            \n            # If the destination file already exists, generate a unique name\n            if os.path.exists(dest_path):\n                base, ext = os.path.splitext(file)\n                dest_path = os.path.join(dest_dir, f\"{base}_from_{os.path.basename(root)}{ext}\")\n            \n            # Move the file\n            shutil.move(source_path, dest_path)\n    \n    return dest_dir\n\ndef rename_files_replace_digits(directory):\n    \"\"\"Rename all files in a directory, replacing each digit with the next digit (1->2, 9->0)\"\"\"\n    renamed_files = []\n    \n    # Process each file in the directory\n    for filename in os.listdir(directory):\n        file_path = os.path.join(directory, filename)\n        \n        # Skip if not a file\n        if not os.path.isfile(file_path):\n            continue\n        \n        # Create new filename by replacing digits\n        new_filename = \"\"\n        for char in filename:\n            if char.isdigit():\n                # Replace digit with the next one (9->0)\n                new_digit = str((int(char) + 1) % 10)\n                new_filename += new_digit\n            else:\n                new_filename += char\n        \n        # Rename the file if the name has changed\n        if new_filename != filename:\n            new_path = os.path.join(directory, new_filename)\n            os.rename(file_path, new_path)\n            renamed_files.append((filename, new_filename))\n    \n    return renamed_files\n\ndef calculate_sha256_hash(directory):\n    \"\"\"Calculate SHA256 hash equivalent to: grep . * | LC_ALL=C sort | sha256sum\"\"\"\n    # Get all files in the directory\n    files = sorted(os.listdir(directory))\n    \n    # Initialize hash object\n    sha256 = hashlib.sha256()\n    \n    # Build content similar to the bash command output\n    all_lines = []\n    \n    for filename in files:\n        filepath = os.path.join(directory, filename)\n        if os.path.isfile(filepath):\n            try:\n                with open(filepath, 'r', errors='replace') as f:\n                    for line_num, line in enumerate(f, 1):\n                        # Skip empty lines\n                        if line.strip():\n                            # Format similar to grep output: filename:line\n                            formatted_line = f\"{filename}:{line}\"\n                            all_lines.append(formatted_line)\n            except Exception as e:\n                print(f\"Error reading file {filename}: {e}\")\n    \n    # Sort lines (LC_ALL=C ensures byte-by-byte sorting)\n    # Python's sorted() is close to this behavior by default\n    sorted_lines = sorted(all_lines)\n    \n    # Update hash with sorted content\n    for line in sorted_lines:\n        sha256.update(line.encode('utf-8'))\n    \n    # Return the hexadecimal digest\n    return sha256.hexdigest()\n\ndef process_zip_file(zip_path=None):\n    \"\"\"Process the zip file: extract, move files, rename, and calculate hash\"\"\"\n    if zip_path is None:\n        # Default value\n        zip_path = \"q-move-rename-files.zip\"\n    \n    # Check if the zip file exists\n    if not os.path.exists(zip_path):\n        script_dir = os.path.dirname(os.path.abspath(__file__))\n        zip_path = os.path.join(script_dir, zip_path)\n        if not os.path.exists(zip_path):\n            print(f\"Error: Zip file '{zip_path}' not found.\")\n            sys.exit(1)\n    \n    # print(f\"Processing zip file: {zip_path}\")\n    \n    # Extract the zip file\n    extract_dir = extract_zip(zip_path)\n    # print(f\"Extracted to: {extract_dir}\")\n    \n    # Create flat directory for all files\n    flat_dir = os.path.join(extract_dir, \"flat_files\")\n    \n    # Move all files to the flat directory\n    move_files_to_flat_folder(extract_dir, flat_dir)\n    # print(f\"Moved all files to: {flat_dir}\")\n    \n    # Rename files replacing digits\n    renamed_files = rename_files_replace_digits(flat_dir)\n    # print(f\"Renamed {len(renamed_files)} files\")\n    \n    # Calculate SHA-256 hash\n    hash_result = calculate_sha256_hash(flat_dir)\n    # print(f\"SHA-256 hash: {hash_result}\")\n    \n    return hash_result\n\nif __name__ == \"__main__\":\n    # Get zip file path from command line argument or use default\n    zip_path = sys.argv[1] if len(sys.argv) > 1 else \"q-move-rename-files.zip\"\n    \n    # Process the zip file and calculate hash\n    result = process_zip_file(zip_path)\n    \n    # Output the hash (suitable for command line output)\n    print(result)"
    },
    {
        "file": "E://data science tool//GA1//seventeenth.py",
        "question": null,
        "parameter": null,
        "code": "import os\nimport zipfile\nimport sys\nfrom pathlib import Path\n\ndef extract_zip(zip_path, extract_dir=None):\n    \"\"\"Extract a zip file to the specified directory\"\"\"\n    if extract_dir is None:\n        extract_dir = Path(zip_path).stem + \"_extracted\"\n    \n    # Create extraction directory if it doesn't exist\n    os.makedirs(extract_dir, exist_ok=True)\n    \n    # Extract the zip file\n    with zipfile.ZipFile(zip_path, 'r') as zip_ref:\n        zip_ref.extractall(extract_dir)\n    \n    return extract_dir\n\ndef count_different_lines(file1_path, file2_path):\n    \"\"\"Count the number of lines that differ between two files\"\"\"\n    different_lines = 0\n    \n    with open(file1_path, 'r', encoding='utf-8') as f1, open(file2_path, 'r', encoding='utf-8') as f2:\n        for line_num, (line1, line2) in enumerate(zip(f1, f2), 1):\n            if line1 != line2:\n                different_lines += 1\n                # print(f\"Line {line_num} differs:\")\n                # print(f\"  a.txt: {line1.rstrip()}\")\n                # print(f\"  b.txt: {line2.rstrip()}\")\n                # print()\n    \n    return different_lines\n\ndef process_zip_file(zip_path=None):\n    \"\"\"Process the zip file to find differences between a.txt and b.txt\"\"\"\n    if zip_path is None:\n        # Default value\n        zip_path = \"q-compare-files.zip\"\n    \n    # Check if the zip file exists\n    if not os.path.exists(zip_path):\n        script_dir = os.path.dirname(os.path.abspath(__file__))\n        zip_path = os.path.join(script_dir, zip_path)\n        if not os.path.exists(zip_path):\n            print(f\"Error: Zip file '{zip_path}' not found.\")\n            sys.exit(1)\n    \n    # print(f\"Processing zip file: {zip_path}\")\n    \n    # Extract the zip file\n    extract_dir = extract_zip(zip_path)\n    # print(f\"Extracted to: {extract_dir}\")\n    \n    # Paths to the two files\n    file1_path = os.path.join(extract_dir, \"a.txt\")\n    file2_path = os.path.join(extract_dir, \"b.txt\")\n    \n    # Check if both files exist\n    if not os.path.exists(file1_path):\n        print(f\"Error: File 'a.txt' not found in the extracted directory.\")\n        sys.exit(1)\n    if not os.path.exists(file2_path):\n        print(f\"Error: File 'b.txt' not found in the extracted directory.\")\n        sys.exit(1)\n    \n    # Count lines in each file\n    with open(file1_path, 'r', encoding='utf-8') as f:\n        line_count_1 = sum(1 for _ in f)\n    with open(file2_path, 'r', encoding='utf-8') as f:\n        line_count_2 = sum(1 for _ in f)\n    \n    # print(f\"a.txt has {line_count_1} lines\")\n    # print(f\"b.txt has {line_count_2} lines\")\n    \n    # Verify they have the same number of lines\n    if line_count_1 != line_count_2:\n        print(f\"Warning: Files have different line counts: a.txt ({line_count_1}) vs b.txt ({line_count_2})\")\n        print(\"Will compare up to the shorter file's length.\")\n    \n    # Count different lines\n    diff_count = count_different_lines(file1_path, file2_path)\n    # print(f\"\\nTotal lines that differ: {diff_count}\")\n    \n    return diff_count\n\nif __name__ == \"__main__\":\n    # Get zip file path from command line argument or use default\n    zip_path = sys.argv[1] if len(sys.argv) > 1 else \"q-compare-files.zip\"\n    \n    # Process the zip file and count differences\n    result = process_zip_file(zip_path)\n    \n    # Output just the number for easy use in command line\n    print(result)"
    },
    {
        "file": "E://data science tool//GA1//eighteenth.py",
        "question": null,
        "parameter": null,
        "code": "import sqlite3\nimport os\nimport sys\n\ndef create_test_database(db_path):\n    \"\"\"Create a test database with sample ticket data if it doesn't exist\"\"\"\n    # Check if database already exists\n    if os.path.exists(db_path):\n        print(f\"Using existing database at {db_path}\")\n        return\n    \n    print(f\"Creating test database at {db_path}\")\n    conn = sqlite3.connect(db_path)\n    cursor = conn.cursor()\n    \n    # Create tickets table\n    cursor.execute('''\n    CREATE TABLE tickets (\n        id INTEGER PRIMARY KEY,\n        type TEXT,\n        units INTEGER,\n        price REAL\n    )\n    ''')\n    \n    # Insert sample data\n    sample_data = [\n        ('bronze', 297, 0.6),\n        ('Bronze', 673, 1.62),\n        ('Silver', 105, 1.26),\n        ('Silver', 82, 0.79),\n        ('SILVER', 121, 0.84),\n        ('Gold', 50, 5.0),\n        ('Gold', 75, 4.75),\n        ('GOLD', 30, 5.5),\n        ('gold', 45, 4.8),\n        ('Bronze', 200, 1.5),\n        ('gold', 60, 5.2),\n    ]\n    \n    cursor.executemany(\n        'INSERT INTO tickets (type, units, price) VALUES (?, ?, ?)',\n        sample_data\n    )\n    \n    conn.commit()\n    conn.close()\n    print(\"Test database created successfully\")\n\ndef calculate_gold_ticket_sales(db_path):\n    \"\"\"Calculate total sales for all Gold ticket types using SQL\"\"\"\n    # Connect to the database\n    conn = sqlite3.connect(db_path)\n    cursor = conn.cursor()\n    \n    # The SQL query to calculate total sales for Gold tickets\n    # Uses LOWER function to make the case-insensitive comparison\n    sql_query = '''\n    SELECT \n        SUM(units * price) as total_sales\n    FROM \n        tickets\n    WHERE \n        LOWER(type) = 'gold'\n    '''\n    \n    # Execute the query\n    cursor.execute(sql_query)\n    result = cursor.fetchone()[0]\n    \n    # Print the SQL query\n    # print(\"SQL Query:\")\n    print(sql_query)\n    \n    # Close the connection\n    conn.close()\n    \n    return result\n\ndef main():\n    # Define the database path\n    db_path = \"tickets_database.db\"\n    \n    # Create the test database if it doesn't exist\n    create_test_database(db_path)\n    \n    # Calculate and display the total sales for Gold tickets\n    total_sales = calculate_gold_ticket_sales(db_path)\n    \n    print(\"\\nResult:\")\n    print(f\"Total sales for Gold tickets: ${total_sales:.2f}\")\n    \n    return total_sales\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
        "file": "E://data science tool//GA2//first.py",
        "question": null,
        "parameter": null,
        "code": "import pandas as pd\nimport matplotlib.pyplot as plt\n\n# Load the step count data\ndef analyze_steps(data_file):\n    df = pd.read_csv(data_file)\n    \n    # Calculate daily averages\n    daily_avg = df.groupby('person')['steps'].mean()\n    \n    # Plot the results\n    plt.figure(figsize=(10, 6))\n    daily_avg.plot(kind='bar')\n    plt.title('Average Daily Steps by Person')\n    plt.ylabel('Steps')\n    plt.savefig('step_analysis.png')\n    \n    return daily_avg\n```\n\n## Data Collection\n\nThe following equipment was used to collect step count data:\n\n- Fitbit Charge 5\n- Apple Watch Series 7\n- Samsung Galaxy Watch 4\n- Google Pixel phone pedometer\n- Garmin Forerunner 245\n\n## Analysis Process\n\nThe analysis followed these steps:\n\n1. Data collection from all participants' devices\n2. Data cleaning to remove outliers and fix missing values\n3. Statistical analysis of daily and weekly patterns\n4. Comparison between participants\n5. Visualization of trends and patterns\n\n## Results\n\n### Personal Step Count Data\n\nThe table below shows my daily step counts compared to the recommended 10,000 steps:\n\n| Day       | Steps  | Target | Difference |\n|-----------|--------|--------|------------|\n| Monday    | 8,543  | 10,000 | -1,457     |\n| Tuesday   | 12,251 | 10,000 | +2,251     |\n| Wednesday | 9,862  | 10,000 | -138       |\n| Thursday  | 11,035 | 10,000 | +1,035     |\n| Friday    | 14,223 | 10,000 | +4,223     |\n| Saturday  | 15,876 | 10,000 | +5,876     |\n| Sunday    | 6,532  | 10,000 | -3,468     |\n\n### Comparative Analysis\n\n![Weekly Step Count Comparison](https://example.com/step_analysis.png)\n\nThe graph above shows that weekend activity levels generally increased for all participants, \nwith Saturday showing the highest average step count.\n\n## Health Insights\n\n> According to the World Health Organization, adults should aim for at least 150 minutes of \n> moderate-intensity physical activity throughout the week, which roughly translates to \n> about 7,000-10,000 steps per day for most people.\n\n## Conclusion and Recommendations\n\nBased on the analysis, I exceeded the target step count on 4 out of 7 days, with particularly \nstrong performance on weekends. The data suggests that I should focus on increasing activity \nlevels on:\n\n- Monday\n- Wednesday\n- Sunday\n\n## Additional Resources\n\nFor more information on the benefits of walking, please visit [The Harvard Health Guide to Walking](https://www.health.harvard.edu/exercise-and-fitness/walking-your-steps-to-health).\n\n\"\"\"\n    return markdown\n\ndef save_markdown_to_file(filename=\"step_analysis.md\"):\n    \"\"\"Saves the generated Markdown to a file\"\"\"\n    markdown_content = generate_step_count_markdown()\n    \n    with open(filename, 'w') as file:\n        file.write(markdown_content)\n    \n    print(f\"Markdown file created successfully: {filename}\")\n\nif __name__ == \"__main__\":\n    # Generate and save the Markdown document\n    save_markdown_to_file(\"step_analysis.md\")\n    \n    # Display the Markdown content in the console as well\n    # print(\"\\nGenerated Markdown content:\")\n    # print(\"-\" * 50)\n    print(generate_step_count_markdown())"
    },
    {
        "file": "E://data science tool//GA2//second.py",
        "question": null,
        "parameter": null,
        "code": "import os\nimport sys\nfrom PIL import Image\nimport io\nimport time\nimport datetime\nimport random\nimport string\nimport warnings\n\n# Suppress PIL warnings\nwarnings.filterwarnings(\"ignore\", category=UserWarning)\n\ndef display_image_in_terminal(image_path):\n    \"\"\"\n    Display an image in the terminal using ASCII characters.\n    \"\"\"\n    try:\n        img = Image.open(image_path).convert('L')\n        \n        width, height = img.size\n        aspect_ratio = height / width\n        new_width = 80\n        new_height = int(aspect_ratio * new_width * 0.4)\n        img = img.resize((new_width, new_height))\n        \n        chars = '@%#*+=-:. '\n        \n        for y in range(new_height):\n            line = \"\"\n            for x in range(new_width):\n                pixel = img.getpixel((x, y))\n                char_idx = min(len(chars) - 1, pixel * len(chars) // 256)\n                line += chars[char_idx]\n            print(line)\n        \n    except Exception:\n        pass\n\ndef generate_unique_filename(original_name):\n    \"\"\"Generate a unique filename\"\"\"\n    name, ext = os.path.splitext(original_name)\n    return f\"{name}_compressed{ext}\"\n\ndef compress_image_losslessly(input_path, max_bytes=1500, output_dir=None):\n    \"\"\"Compress an image losslessly to be under the specified max_bytes.\"\"\"\n    try:\n        # Check if input file exists - important to provide feedback\n        if not os.path.exists(input_path):\n            print(f\"Error: Input file not found at '{input_path}'\")\n            return None\n        \n        original_img = Image.open(input_path)\n        img_format = original_img.format\n        \n        input_file_size = os.path.getsize(input_path)\n        if input_file_size <= max_bytes:\n            return input_path\n            \n        if output_dir is None:\n            output_dir = os.path.dirname(os.path.abspath(input_path))\n        \n        if not os.path.exists(output_dir):\n            os.makedirs(output_dir)\n        \n        file_name = os.path.basename(input_path)\n        new_filename = generate_unique_filename(file_name)\n        output_path = os.path.join(output_dir, new_filename)\n        \n        if img_format not in [\"PNG\", \"GIF\"]:\n            img_format = \"PNG\"\n            \n        # Strategy 1: PNG compression\n        if img_format == \"PNG\":\n            for compression in range(9, -1, -1):\n                original_img.save(output_path, format=\"PNG\", optimize=True, compress_level=compression)\n                if os.path.getsize(output_path) <= max_bytes:\n                    return output_path\n        \n        # Strategy 2: Color reduction\n        max_colors = 256\n        while max_colors >= 2:\n            palette_img = original_img.convert('P', palette=Image.ADAPTIVE, colors=max_colors)\n            palette_img.save(output_path, format=img_format, optimize=True)\n            if os.path.getsize(output_path) <= max_bytes:\n                return output_path\n            max_colors = max_colors // 2\n        \n        # Strategy 3: Resize\n        width, height = original_img.size\n        scale_factor = 0.9\n        \n        while scale_factor > 0.1:\n            new_width = int(width * scale_factor)\n            new_height = int(height * scale_factor)\n            resized_img = original_img.resize((new_width, new_height), Image.LANCZOS)\n            resized_img.save(output_path, format=img_format, optimize=True)\n            if os.path.getsize(output_path) <= max_bytes:\n                return output_path\n            scale_factor -= 0.1\n        \n        return None\n        \n    except Exception as e:\n        print(f\"Error compressing image: {e}\")\n        return None\n\ndef find_image_path(image_name):\n    \"\"\"\n    Look for an image in multiple possible locations:\n    1. Current directory\n    2. Script directory\n    3. Data directory\n    \"\"\"\n    # Check current directory\n    if os.path.exists(image_name):\n        return os.path.abspath(image_name)\n    \n    # Check script directory\n    script_dir = os.path.dirname(os.path.abspath(__file__))\n    script_path = os.path.join(script_dir, image_name)\n    if os.path.exists(script_path):\n        return script_path\n    \n    # Check parent directory\n    parent_dir = os.path.dirname(script_dir)\n    parent_path = os.path.join(parent_dir, image_name)\n    if os.path.exists(parent_path):\n        return parent_path\n    \n    # Check for GA2 folder\n    ga2_dir = os.path.join(parent_dir, \"GA2\")\n    ga2_path = os.path.join(ga2_dir, image_name)\n    if os.path.exists(ga2_path):\n        return ga2_path\n    \n    return None\n\ndef main():\n    # Default values\n    image_name = \"iit_madras.png\"\n    max_bytes = 1500\n    output_dir = \"./compressed\"\n    \n    # Override with command line arguments if provided\n    if len(sys.argv) > 1:\n        image_name = sys.argv[1]\n    if len(sys.argv) > 2:\n        try:\n            max_bytes = int(sys.argv[2])\n        except ValueError:\n            pass\n    if len(sys.argv) > 3:\n        output_dir = sys.argv[3]\n    \n    # Find the image path\n    image_path = find_image_path(image_name)\n    \n    if not image_path:\n        print(f\"Error: Could not find image '{image_name}'\")\n        print(\"Please specify the correct path to the image or place it in the current directory.\")\n        return\n    \n    # Compress the image\n    result_path = compress_image_losslessly(image_path, max_bytes, output_dir)\n    \n    if result_path:\n        print(f\"{result_path}\")\n        display_image_in_terminal(result_path)\n    \nif __name__ == \"__main__\":\n    # Allow stderr for critical errors but redirect for PIL warnings\n    old_stderr = sys.stderr\n    sys.stderr = open(os.devnull, 'w')\n    \n    try:\n        main()\n    finally:\n        # Restore stderr\n        sys.stderr.close()\n        sys.stderr = old_stderr"
    },
    {
        "file": "E://data science tool//GA2//third.py",
        "question": null,
        "parameter": null,
        "code": "import os\nimport sys\nimport subprocess\nimport tempfile\nimport json\nimport time\nimport getpass\nimport platform\nimport base64\nimport urllib.request\nimport urllib.error\nfrom pathlib import Path\nfrom dotenv import load_dotenv\n\ndef load_env_file():\n    \"\"\"Load environment variables from .env file\"\"\"\n    # Look for .env file in multiple locations\n    search_paths = [\n        '.env',  # Current directory\n        os.path.join(os.path.dirname(os.path.abspath(__file__)), '.env'),  # Script directory\n        os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), '.env'),  # Parent directory\n    ]\n    \n    for env_path in search_paths:\n        if os.path.exists(env_path):\n            print(f\"Loading environment variables from {env_path}\")\n            load_dotenv(env_path)\n            return True\n    \n    print(\"No .env file found in any of the search paths.\")\n    print(\"Please create a .env file with: GITHUB_TOKEN=your_token_here\")\n    return False\n\ndef get_github_token():\n    \"\"\"Get GitHub token from environment variable or prompt user.\"\"\"\n    # First try to load from .env file\n    load_env_file()\n    \n    # Check multiple possible environment variable names\n    token = os.environ.get(\"GITHUB_TOKEN\") or os.environ.get(\"GITHUB_API_KEY\")\n    \n    if not token:\n        print(\"GitHub Personal Access Token not found in environment variables.\")\n        print(\"Please create a .env file with GITHUB_TOKEN=your_token\")\n        print(\"Create a token at: https://github.com/settings/tokens\")\n        \n        # As a fallback, prompt user for token\n        token = getpass.getpass(\"Enter your GitHub Personal Access Token: \")\n    else:\n        print(\"Successfully found GitHub token in environment variables.\")\n    \n    return token\n\ndef get_github_username(token):\n    \"\"\"Get GitHub username using the token.\"\"\"\n    headers = {\n        \"Authorization\": f\"token {token}\",\n        \"Accept\": \"application/vnd.github.v3+json\"\n    }\n    \n    try:\n        request = urllib.request.Request(\"https://api.github.com/user\", headers=headers)\n        with urllib.request.urlopen(request) as response:\n            user_data = json.loads(response.read().decode())\n            return user_data.get(\"login\")\n    except Exception as e:\n        print(f\"Error getting GitHub username: {e}\")\n        return None\n\ndef create_github_pages_repo(token, username, repo_name=\"my-portfolio-page\"):\n    \"\"\"Create a GitHub repository for GitHub Pages.\"\"\"\n    headers = {\n        \"Authorization\": f\"token {token}\",\n        \"Accept\": \"application/vnd.github.v3+json\",\n        \"Content-Type\": \"application/json\"\n    }\n    \n    # Check if repo already exists\n    try:\n        request = urllib.request.Request(\n            f\"https://api.github.com/repos/{username}/{repo_name}\", \n            headers=headers\n        )\n        with urllib.request.urlopen(request) as response:\n            # Repo exists\n            print(f\"Repository {repo_name} already exists. Using existing repository.\")\n            return repo_name\n    except urllib.error.HTTPError as e:\n        if e.code != 404:\n            print(f\"Error checking if repository exists: {e}\")\n            return None\n    \n    # Create the repository\n    data = json.dumps({\n        \"name\": repo_name,\n        \"description\": \"My portfolio page created with GitHub Pages\",\n        \"homepage\": f\"https://{username}.github.io/{repo_name}\",\n        \"private\": False,\n        \"has_issues\": False,\n        \"has_projects\": False,\n        \"has_wiki\": False,\n        \"auto_init\": True  # Initialize with a README\n    }).encode()\n    \n    try:\n        request = urllib.request.Request(\n            \"https://api.github.com/user/repos\",\n            data=data,\n            headers=headers,\n            method=\"POST\"\n        )\n        with urllib.request.urlopen(request) as response:\n            repo_data = json.loads(response.read().decode())\n            print(f\"Repository {repo_name} created successfully!\")\n            # Wait a moment for GitHub to initialize the repository\n            time.sleep(3)\n            return repo_name\n    except Exception as e:\n        print(f\"Error creating repository: {e}\")\n        return None\n\ndef create_html_content(email):\n    \"\"\"Create HTML content for the GitHub Pages site.\"\"\"\n    return f\"\"\"<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>My Portfolio Page</title>\n    <style>\n        body {{\n            font-family: Arial, sans-serif;\n            line-height: 1.6;\n            margin: 0;\n            padding: 0;\n            color: #333;\n            background-color: #f4f4f4;\n        }}\n        header {{\n            background-color: #35424a;\n            color: white;\n            padding: 20px;\n            text-align: center;\n        }}\n        .container {{\n            width: 80%;\n            margin: auto;\n            overflow: hidden;\n            padding: 20px;\n        }}\n        .project {{\n            background: #fff;\n            padding: 20px;\n            margin-bottom: 20px;\n            border-radius: 5px;\n            box-shadow: 0 2px 5px rgba(0,0,0,0.1);\n        }}\n        footer {{\n            background-color: #35424a;\n            color: white;\n            text-align: center;\n            padding: 20px;\n            margin-top: 20px;\n        }}\n        .email {{\n            color: #666;\n            font-style: italic;\n        }}\n    </style>\n</head>\n<body>\n    <header>\n        <h1>My Data Science Portfolio</h1>\n        <p>Showcasing my projects and skills</p>\n    </header>\n    \n    <div class=\"container\">\n        <h2>About Me</h2>\n        <p>\n            I am a passionate data scientist with expertise in machine learning, data visualization, \n            and statistical analysis. I enjoy solving complex problems and turning data into actionable insights.\n        </p>\n        \n        <h2>Projects</h2>\n        \n        <div class=\"project\">\n            <h3>Time Series Analysis</h3>\n            <p>\n                Used ARIMA and LSTM models to forecast stock prices with 85% accuracy.\n            </p>\n        </div>\n        \n        <div class=\"project\">\n            <h3>Image Classification</h3>\n            <p>\n                Developed a CNN model for classifying images with 92% accuracy using TensorFlow.\n            </p>\n        </div>\n        \n        <div class=\"project\">\n            <h3>Natural Language Processing</h3>\n            <p>\n                Built a sentiment analysis tool for analyzing customer reviews using BERT.\n            </p>\n        </div>\n        \n        <h2>Skills</h2>\n        <ul>\n            <li>Python (Pandas, NumPy, Scikit-learn)</li>\n            <li>Data Visualization (Matplotlib, Seaborn, Plotly)</li>\n            <li>Machine Learning (Supervised and Unsupervised)</li>\n            <li>Deep Learning (TensorFlow, PyTorch)</li>\n            <li>SQL and Database Management</li>\n            <li>Big Data Technologies (Spark, Hadoop)</li>\n        </ul>\n    </div>\n    \n    <footer>\n        <p>Contact me at: </p>\n        <p class=\"email\"><!--email_off-->{email}<!--/email_off--></p>\n        <p>&copy; 2025 My Portfolio. All rights reserved.</p>\n    </footer>\n</body>\n</html>\n\"\"\"\n\ndef check_file_exists(token, username, repo_name, path, branch):\n    \"\"\"Check if a file already exists in the repository.\"\"\"\n    headers = {\n        \"Authorization\": f\"token {token}\",\n        \"Accept\": \"application/vnd.github.v3+json\"\n    }\n    \n    try:\n        request = urllib.request.Request(\n            f\"https://api.github.com/repos/{username}/{repo_name}/contents/{path}?ref={branch}\",\n            headers=headers\n        )\n        with urllib.request.urlopen(request) as response:\n            return True\n    except urllib.error.HTTPError:\n        return False\n\ndef create_and_push_content_directly(token, username, repo_name, email):\n    \"\"\"Create content directly using GitHub API instead of git push.\"\"\"\n    headers = {\n        \"Authorization\": f\"token {token}\",\n        \"Accept\": \"application/vnd.github.v3+json\",\n        \"Content-Type\": \"application/json\"\n    }\n    \n    # Create index.html content\n    html_content = create_html_content(email)\n    content_encoded = base64.b64encode(html_content.encode()).decode()\n    \n    # Determine which branch to use\n    try:\n        # Check for main branch\n        request = urllib.request.Request(\n            f\"https://api.github.com/repos/{username}/{repo_name}/branches/main\",\n            headers=headers\n        )\n        try:\n            urllib.request.urlopen(request)\n            branch = \"main\"\n        except:\n            # Try master branch\n            branch = \"master\"\n        \n        print(f\"Using branch: {branch}\")\n        \n        # Check if file already exists\n        file_exists = check_file_exists(token, username, repo_name, \"index.html\", branch)\n        \n        if file_exists:\n            print(\"index.html already exists. Getting current file to update it.\")\n            # Need to get the current file's SHA to update it\n            request = urllib.request.Request(\n                f\"https://api.github.com/repos/{username}/{repo_name}/contents/index.html?ref={branch}\",\n                headers=headers\n            )\n            with urllib.request.urlopen(request) as response:\n                file_data = json.loads(response.read().decode())\n                sha = file_data.get(\"sha\")\n                \n                # Create update data with SHA\n                update_data = {\n                    \"message\": \"Update portfolio page with protected email\",\n                    \"content\": content_encoded,\n                    \"branch\": branch,\n                    \"sha\": sha\n                }\n                \n                # Update the file\n                request = urllib.request.Request(\n                    f\"https://api.github.com/repos/{username}/{repo_name}/contents/index.html\",\n                    data=json.dumps(update_data).encode(),\n                    headers=headers,\n                    method=\"PUT\"\n                )\n                \n                with urllib.request.urlopen(request) as response:\n                    print(f\"Portfolio page updated successfully in the {branch} branch!\")\n                    return True\n        else:\n            # File doesn't exist, create it\n            create_data = {\n                \"message\": \"Add portfolio page with protected email\",\n                \"content\": content_encoded,\n                \"branch\": branch\n            }\n            \n            # Create the file\n            request = urllib.request.Request(\n                f\"https://api.github.com/repos/{username}/{repo_name}/contents/index.html\",\n                data=json.dumps(create_data).encode(),\n                headers=headers,\n                method=\"PUT\"\n            )\n            \n            with urllib.request.urlopen(request) as response:\n                print(f\"Portfolio page created successfully in the {branch} branch!\")\n                return True\n    \n    except Exception as e:\n        print(f\"Error creating/updating index.html: {e}\")\n        # Try a different approach for creating content\n        try:\n            print(\"Trying alternative approach to create content...\")\n            # Get the current repo structure\n            request = urllib.request.Request(\n                f\"https://api.github.com/repos/{username}/{repo_name}\",\n                headers=headers\n            )\n            with urllib.request.urlopen(request) as response:\n                repo_info = json.loads(response.read().decode())\n                default_branch = repo_info.get(\"default_branch\", \"main\")\n                \n            print(f\"Default branch is: {default_branch}\")\n            \n            # Create content using default branch\n            create_data = {\n                \"message\": \"Add portfolio page with protected email\",\n                \"content\": content_encoded,\n                \"branch\": default_branch\n            }\n            \n            request = urllib.request.Request(\n                f\"https://api.github.com/repos/{username}/{repo_name}/contents/index.html\",\n                data=json.dumps(create_data).encode(),\n                headers=headers,\n                method=\"PUT\"\n            )\n            \n            with urllib.request.urlopen(request) as response:\n                print(f\"Portfolio page created successfully using alternative approach!\")\n                return True\n                \n        except Exception as e2:\n            print(f\"Alternative approach also failed: {e2}\")\n            return False\n\ndef enable_github_pages(token, username, repo_name):\n    \"\"\"Enable GitHub Pages in the repository settings.\"\"\"\n    headers = {\n        \"Authorization\": f\"token {token}\",\n        \"Accept\": \"application/vnd.github.v3+json\",\n        \"Content-Type\": \"application/json\"\n    }\n    \n    # Get repository info to determine default branch\n    try:\n        request = urllib.request.Request(\n            f\"https://api.github.com/repos/{username}/{repo_name}\",\n            headers=headers\n        )\n        with urllib.request.urlopen(request) as response:\n            repo_info = json.loads(response.read().decode())\n            branch = repo_info.get(\"default_branch\", \"main\")\n    except:\n        # Fall back to trying main\n        branch = \"main\"\n    \n    print(f\"Enabling GitHub Pages with branch: {branch}\")\n    \n    data = json.dumps({\n        \"source\": {\n            \"branch\": branch,\n            \"path\": \"/\"\n        }\n    }).encode()\n    \n    try:\n        request = urllib.request.Request(\n            f\"https://api.github.com/repos/{username}/{repo_name}/pages\",\n            data=data,\n            headers=headers,\n            method=\"POST\"\n        )\n        urllib.request.urlopen(request)\n        print(\"GitHub Pages enabled successfully!\")\n        \n        # GitHub Pages URL format\n        pages_url = f\"https://{username}.github.io/{repo_name}\"\n        print(f\"GitHub Pages will be available at: {pages_url}\")\n        return pages_url\n        \n    except Exception as e:\n        print(f\"Error enabling GitHub Pages: {e}\")\n        print(f\"Please enable GitHub Pages manually in repository settings.\")\n        print(f\"Your site will be available at: https://{username}.github.io/{repo_name}\")\n        return f\"https://{username}.github.io/{repo_name}\"\n\ndef create_env_file(token=None):\n    \"\"\"Create a .env file with the provided token.\"\"\"\n    if not token:\n        token = getpass.getpass(\"Enter your GitHub Personal Access Token to save in .env file: \")\n    \n    env_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), '.env')\n    \n    try:\n        with open(env_path, 'w') as f:\n            f.write(f\"GITHUB_TOKEN={token}\\n\")\n        print(f\".env file created at: {env_path}\")\n        # Reload environment variables\n        load_dotenv(env_path)\n        return True\n    except Exception as e:\n        print(f\"Error creating .env file: {e}\")\n        return False\n\ndef create_github_pages_site():\n    \"\"\"Main function to create a GitHub Pages site.\"\"\"\n    print(\"Creating GitHub Pages Portfolio with Email Integration\")\n    print(\"-\" * 50)\n    \n    # Get GitHub token from .env file\n    token = get_github_token()\n    \n    if not token:\n        print(\"GitHub token is required to continue.\")\n        create_env_file()\n        token = os.environ.get(\"GITHUB_TOKEN\")\n        if not token:\n            return None\n    \n    # Get GitHub username\n    username = get_github_username(token)\n    if not username:\n        print(\"Could not retrieve GitHub username.\")\n        return None\n    \n    print(f\"Using GitHub account: {username}\")\n    \n    # Create GitHub repository\n    repo_name = create_github_pages_repo(token, username)\n    if not repo_name:\n        print(\"Failed to create GitHub repository.\")\n        return None\n    \n    # Create and push content directly using GitHub API (no git required)\n    email = \"24f2006438@ds.study.iitm.ac.in\"\n    if not create_and_push_content_directly(token, username, repo_name, email):\n        print(\"Failed to create portfolio content.\")\n        return None\n    \n    # Enable GitHub Pages\n    pages_url = enable_github_pages(token, username, repo_name)\n    \n    print(\"\\nSummary:\")\n    print(\"-\" * 50)\n    print(f\"Repository: https://github.com/{username}/{repo_name}\")\n    print(f\"GitHub Pages URL: {pages_url}\")\n    print(\"Your email is properly protected against email harvesters.\")\n    print(\"\\nNOTE: GitHub Pages may take a few minutes to become available.\")\n    \n    return pages_url\n\nif __name__ == \"__main__\":\n    try:\n        # Check if .env exists, create it if not\n        env_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), '.env')\n        if not os.path.exists(env_path):\n            print(\"No .env file found. Creating one now.\")\n            create_env_file()\n        \n        result = create_github_pages_site()\n        if result:\n            print(\"\\nYour GitHub Pages URL (copy this):\")\n            print(result)\n    except Exception as e:\n        print(f\"An error occurred: {e}\")"
    },
    {
        "file": "E://data science tool//GA2//fourth.py",
        "question": null,
        "parameter": null,
        "code": "import hashlib\nimport datetime\n\ndef calculate_equivalent_hash(email, year=None):\n    \"\"\"\n    Calculates a hash equivalent to the one generated in Google Colab.\n    \n    Args:\n        email: The email address to use in the hash\n        year: Year to use (defaults to current year if not specified)\n        \n    Returns:\n        The last 5 characters of the hash\n    \"\"\"\n    # Use current year if not specified (Google uses token expiry year)\n    if year is None:\n        year = datetime.datetime.now().year\n    \n    # Create hash from email and year (same format as the Colab code)\n    hash_input = f\"{email} {year}\"\n    hash_value = hashlib.sha256(hash_input.encode()).hexdigest()\n    \n    # Get last 5 characters\n    result = hash_value[-5:]\n    \n    return result\n\ndef main():\n    \"\"\"Main function to calculate the hash for the specific email.\"\"\"\n    # The email from the problem statement\n    email = \"24f2006438@ds.study.iitm.ac.in\"\n    \n    # Calculate using current year\n    current_year = datetime.datetime.now().year\n    result = calculate_equivalent_hash(email, current_year)\n    \n    # print(f\"Email used: {email}\")\n    # print(f\"Year used for calculation: {current_year}\")\n    # print(f\"Calculated 5-character result: {result}\")\n    print(result)\n    \n    # # Calculate for multiple years to provide options\n    # print(\"\\nPossible results for different years:\")\n    for year in range(current_year - 1, current_year + 2):\n        # result = calculate_equivalent_hash(email, year)\n        # print(f\"For year {year}: {result}\")\n        pass\n    \n    # print(\"\\nINFORMATION:\")\n    # print(\"This script calculates a result equivalent to what you'd get from running\")\n    # print(\"the Google Colab authentication code with your email.\")\n    # print(\"The actual result depends on the token expiry year used in Google Colab.\")\n    # print(\"If the result doesn't match, try using a different year value.\")\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
        "file": "E://data science tool//GA2//fifth.py",
        "question": null,
        "parameter": null,
        "code": "import numpy as np\nfrom PIL import Image\nimport colorsys\nimport os\nimport sys\n\ndef count_light_pixels(image_path):\n    \"\"\"\n    Count the number of pixels in an image with lightness > 0.718\n    \n    Args:\n        image_path: Path to the image file\n        \n    Returns:\n        Number of pixels with lightness > 0.718\n    \"\"\"\n    try:\n        # Load the image\n        image = Image.open(image_path)\n        \n        # Convert to numpy array and normalize to 0-1 range\n        rgb = np.array(image) / 255.0\n        \n        # Calculate lightness for each pixel (second value in HLS)\n        # Handle grayscale images by adding a channel dimension if needed\n        if len(rgb.shape) == 2:\n            # Grayscale image - replicate to 3 channels\n            rgb = np.stack([rgb, rgb, rgb], axis=2)\n        elif rgb.shape[2] == 4:\n            # Image with alpha channel - use only RGB\n            rgb = rgb[:, :, :3]\n        \n        # Apply colorsys.rgb_to_hls to each pixel and extract lightness (index 1)\n        lightness = np.apply_along_axis(lambda x: colorsys.rgb_to_hls(*x)[1], 2, rgb)\n        \n        # Count pixels with lightness > 0.718\n        light_pixels = np.sum(lightness > 0.718)\n        \n        return light_pixels\n    except Exception as e:\n        print(f\"Error processing image: {e}\")\n        return None\n\ndef main():\n    \"\"\"Main function to process the image provided as command line argument\"\"\"\n    # Check if image path is provided as command line argument\n    if len(sys.argv) > 1:\n        image_path = sys.argv[1]\n    else:\n        # Default to lenna.webp in the current directory\n        image_path = \"GA2\\\\lenna.webp\"\n    \n    # Check if the image file exists\n    if not os.path.exists(image_path):\n        print(f\"Error: Image file not found: {image_path}\")\n        print(\"Please provide the correct path to the image file.\")\n        print(\"Usage: python fifth.py [path_to_image]\")\n        print(\"Example: python fifth.py lenna.webp\")\n        return\n    \n    # Count light pixels\n    light_pixels = count_light_pixels(image_path)\n    \n    if light_pixels is not None:\n        # print(f\"Number of pixels with lightness > 0.718: {light_pixels}\")\n        print(light_pixels)\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
        "file": "E://data science tool//GA2//sixth.py",
        "question": null,
        "parameter": null,
        "code": "import json\nimport os\nimport sys\nimport shutil\nimport subprocess\nfrom http.server import BaseHTTPRequestHandler, HTTPServer\nfrom urllib.parse import parse_qs, urlparse\n\n# Load student data from JSON file\ndef load_student_data(json_path=\"E:\\\\data science tool\\\\GA2\\\\q-vercel-python.json\"):\n    try:\n        with open(json_path, 'r') as file:\n            students = json.load(file)\n            # Create a dictionary for faster lookups while preserving the original data\n            student_dict = {student[\"name\"]: student[\"marks\"] for student in students}\n            return students, student_dict\n    except Exception as e:\n        print(f\"Error loading student data: {e}\")\n        return [], {}\n\nclass StudentMarksHandler(BaseHTTPRequestHandler):\n    def do_GET(self):\n        # Parse URL and path\n        parsed_url = urlparse(self.path)\n        path = parsed_url.path\n        \n        # Check if this is the root path\n        if path == '/':\n            # Serve a welcome page with instructions\n            self.send_response(200)\n            self.send_header('Content-type', 'text/html')\n            self.end_headers()\n            \n            # Get some sample student names for examples\n            json_path = getattr(self.server, 'json_path', 'E:\\\\data science tool\\\\GA2\\\\q-vercel-python.json')\n            students, student_dict = load_student_data(json_path)\n            sample_names = list(student_dict.keys())[:5]  # Get first 5 names\n            \n            # Create example URLs\n            example1 = f\"/api?name={sample_names[0]}\" if sample_names else \"/api?name=H\"\n            example2 = f\"/api?name={sample_names[0]}&name={sample_names[1]}\" if len(sample_names) > 1 else \"/api?name=H&name=F\"\n            \n            html = f\"\"\"\n            <html>\n            <head>\n                <title>Student Marks API</title>\n                <style>\n                    body {{ font-family: Arial, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; }}\n                    h1 {{ color: #333; }}\n                    pre {{ background: #f4f4f4; padding: 10px; border-radius: 5px; overflow: auto; }}\n                    .example {{ margin-top: 20px; }}\n                    .result {{ color: #060; }}\n                    code {{ background: #f0f0f0; padding: 2px 4px; border-radius: 3px; }}\n                </style>\n            </head>\n            <body>\n                <h1>Student Marks API</h1>\n                <p>This API returns student marks based on their names.</p>\n                \n                <h2>How to Use the API</h2>\n                <p>To get student marks, make a GET request to <code>/api</code> with <code>name</code> query parameters:</p>\n                <pre>/api?name=StudentName1&name=StudentName2</pre>\n                \n                <div class=\"example\">\n                    <h3>Examples:</h3>\n                    <p><a href=\"{example1}\" target=\"_blank\">{example1}</a></p>\n                    <p><a href=\"{example2}\" target=\"_blank\">{example2}</a></p>\n                    <p><a href=\"/api\" target=\"_blank\">/api</a> (returns all student data)</p>\n                </div>\n                \n                <div class=\"example\">\n                    <h3>Response Format</h3>\n                    <p>When querying by name, the API returns a JSON object with a <code>marks</code> array:</p>\n                    <pre class=\"result\">{{\n  \"marks\": [80, 92]\n}}</pre>\n                    <p>When accessing <code>/api</code> without parameters, it returns the complete student data array.</p>\n                </div>\n                \n                <div class=\"example\">\n                    <h3>Available Student Names</h3>\n                    <p>Here are some sample student names you can use:</p>\n                    <ul>\n                        {\"\".join(f'<li><a href=\"/api?name={name}\">{name}</a></li>' for name in sample_names[:10])}\n                    </ul>\n                    <p>Total number of students in database: {len(students)}</p>\n                </div>\n                \n                <hr>\n                <p>This API was built for the IITM BS Degree assignment.</p>\n            </body>\n            </html>\n            \"\"\"\n            self.wfile.write(html.encode())\n            return\n        \n        # Handle API requests\n        if path == '/api':\n            # Enable CORS for all origins\n            self.send_response(200)\n            self.send_header('Content-type', 'application/json')\n            self.send_header('Access-Control-Allow-Origin', '*')\n            self.send_header('Access-Control-Allow-Methods', 'GET')\n            self.send_header('Access-Control-Allow-Headers', 'Content-Type')\n            self.end_headers()\n            \n            # Parse query parameters\n            query_string = parsed_url.query\n            query_params = parse_qs(query_string)\n            \n            # Get names from query\n            requested_names = query_params.get('name', [])\n            \n            # Load student data\n            json_path = getattr(self.server, 'json_path', 'E:\\\\data science tool\\\\GA2\\\\q-vercel-python.json')\n            students, student_dict = load_student_data(json_path)\n            \n            # If no names are requested, return the whole dataset\n            if not requested_names:\n                self.wfile.write(json.dumps(students).encode())\n                return\n                \n            # Otherwise, get marks for requested names\n            marks = [student_dict.get(name, 0) for name in requested_names]\n            \n            # Return JSON response\n            response = {\"marks\": marks}\n            self.wfile.write(json.dumps(response).encode())\n        else:\n            # Handle 404 for any other path\n            self.send_response(404)\n            self.send_header('Content-type', 'text/html')\n            self.end_headers()\n            self.wfile.write(b\"404 Not Found\")\n\ndef run_local_server(json_path=\"E:\\\\data science tool\\\\GA2\\\\q-vercel-python.json\", port=3000):\n    \"\"\"Run a local HTTP server for testing\"\"\"\n    server = HTTPServer(('localhost', port), StudentMarksHandler)\n    server.json_path = json_path  # Attach the JSON path to the server\n    \n    print(f\"Server running on http://localhost:{port}\")\n    print(f\"Open your browser to http://localhost:{port}/ for instructions\")\n    print(f\"Get all student data: http://localhost:{port}/api\")\n    print(f\"Get specific student marks: http://localhost:{port}/api?name=H&name=F\")\n    print(\"Press Ctrl+C to stop the server\")\n    \n    try:\n        server.serve_forever()\n    except KeyboardInterrupt:\n        server.server_close()\n        print(\"Server stopped.\")\n\ndef prepare_vercel_deployment(json_path=\"E:\\\\data science tool\\\\GA2\\\\q-vercel-python.json\"):\n    \"\"\"Prepare files for Vercel deployment\"\"\"\n    # Create api directory if it doesn't exist\n    os.makedirs('api', exist_ok=True)\n    \n    # Create the API handler file for Vercel\n    with open('api/index.py', 'w') as api_file:\n        api_file.write(\"\"\"import json\nimport os\nfrom http.server import BaseHTTPRequestHandler\nfrom urllib.parse import parse_qs, urlparse\n\n# Load student data from JSON file\ndef load_student_data():\n    # In Vercel, the JSON file will be in the same directory as this script\n    json_path = os.path.join(os.path.dirname(__file__), 'q-vercel-python.json')\n    try:\n        with open(json_path, 'r') as file:\n            students = json.load(file)\n            # Create a dictionary for faster lookups while preserving the original data\n            student_dict = {student[\"name\"]: student[\"marks\"] for student in students}\n            return students, student_dict\n    except Exception as e:\n        print(f\"Error loading student data: {e}\")\n        return [], {}\n\nclass handler(BaseHTTPRequestHandler):\n    def do_GET(self):\n        # Enable CORS for all origins\n        self.send_response(200)\n        self.send_header('Content-type', 'application/json')\n        self.send_header('Access-Control-Allow-Origin', '*')\n        self.send_header('Access-Control-Allow-Methods', 'GET')\n        self.send_header('Access-Control-Allow-Headers', 'Content-Type')\n        self.end_headers()\n        \n        # Parse query parameters\n        parsed_url = urlparse(self.path)\n        query_string = parsed_url.query\n        query_params = parse_qs(query_string)\n        \n        # Get names from query\n        requested_names = query_params.get('name', [])\n        \n        # Load student data\n        students, student_dict = load_student_data()\n        \n        # If no names are requested, return the whole dataset\n        if not requested_names:\n            self.wfile.write(json.dumps(students).encode())\n            return\n            \n        # Otherwise, get marks for requested names\n        marks = [student_dict.get(name, 0) for name in requested_names]\n        \n        # Return JSON response\n        response = {\"marks\": marks}\n        self.wfile.write(json.dumps(response).encode())\n\"\"\")\n    \n    # Create vercel.json configuration file\n    with open('vercel.json', 'w') as config_file:\n        config_file.write(\"\"\"{\n  \"version\": 2,\n  \"functions\": {\n    \"api/index.py\": {\n      \"memory\": 128,\n      \"maxDuration\": 10\n    }\n  },\n  \"routes\": [\n    {\n      \"src\": \"/api(.*)\",\n      \"dest\": \"/api\"\n    }\n  ]\n}\"\"\")\n    \n    # Copy the JSON data file to the api directory with a simplified name\n    # We need to rename it for Vercel since it can't handle Windows paths\n    output_path = 'api/q-vercel-python.json'\n    shutil.copy(json_path, output_path)\n    \n    print(\"Files prepared for Vercel deployment:\")\n    print(\"- api/index.py\")\n    print(f\"- {output_path}\")\n    print(\"- vercel.json\")\n\ndef deploy_to_vercel():\n    \"\"\"Deploy the app to Vercel using the Vercel CLI\"\"\"\n    try:\n        # Check if Vercel CLI is installed\n        subprocess.run([\"vercel\", \"--version\"], check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n    except:\n        print(\"Vercel CLI not found. Please install it with: npm install -g vercel\")\n        print(\"After installation, run: vercel --prod\")\n        return False\n    \n    # Deploy to Vercel\n    print(\"Deploying to Vercel...\")\n    try:\n        result = subprocess.run([\"vercel\", \"--prod\"], capture_output=True, text=True)\n        \n        # Extract the deployment URL\n        for line in result.stdout.split('\\n'):\n            if \"https://\" in line and \"vercel.app\" in line:\n                url = line.strip()\n                print(f\"Deployed to: {url}\")\n                print(f\"API endpoint: {url}/api\")\n                return True\n        \n        print(\"Deployment finished but URL not found in output.\")\n        print(\"Check your Vercel dashboard for the deployed URL.\")\n        return True\n    except Exception as e:\n        print(f\"Error during deployment: {e}\")\n        return False\n\ndef main():\n    \"\"\"Main function to handle command line options\"\"\"\n    import argparse\n    \n    parser = argparse.ArgumentParser(description='Student Marks API Server')\n    parser.add_argument('--json', default='E:\\\\data science tool\\\\GA2\\\\q-vercel-python.json', \n                        help='Path to the JSON file with student data')\n    parser.add_argument('--port', type=int, default=3000, \n                        help='Port to run the local server on (default: 3000)')\n    \n    subparsers = parser.add_subparsers(dest='command', help='Command to run')\n    \n    # Server command\n    server_parser = subparsers.add_parser('server', help='Run a local HTTP server')\n    \n    # Prepare command\n    prepare_parser = subparsers.add_parser('prepare', help='Prepare files for Vercel deployment')\n    \n    # Deploy command\n    deploy_parser = subparsers.add_parser('deploy', help='Deploy to Vercel')\n    \n    args = parser.parse_args()\n    \n    # Check if the JSON file exists\n    if not os.path.exists(args.json):\n        print(f\"Error: JSON file not found: {args.json}\")\n        return\n    \n    # Execute the appropriate command\n    if args.command == 'server':\n        run_local_server(args.json, args.port)\n    elif args.command == 'prepare':\n        prepare_vercel_deployment(args.json)\n    elif args.command == 'deploy':\n        prepare_vercel_deployment(args.json)\n        deploy_to_vercel()\n    else:\n        # Default: run the local server\n        run_local_server(args.json, args.port)\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
        "file": "E://data science tool//GA2//seventh.py",
        "question": null,
        "parameter": null,
        "code": "import os\nimport sys\nimport subprocess\nimport tempfile\nimport json\nimport requests\nimport time\nimport shutil\nfrom pathlib import Path\nfrom dotenv import load_dotenv\n\ndef load_env_variables():\n    \"\"\"Load environment variables from .env file\"\"\"\n    # Look for .env file in multiple locations\n    search_paths = [\n        '.env',  # Current directory\n        os.path.join(os.path.dirname(os.path.abspath(__file__)), '.env'),  # Script directory\n        os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), '.env'),  # Parent directory\n    ]\n    \n    for env_path in search_paths:\n        if os.path.exists(env_path):\n            print(f\"Loading environment variables from {env_path}\")\n            load_dotenv(env_path)\n            return True\n    \n    print(\"No .env file found. Please create one with your GITHUB_TOKEN.\")\n    return False\n\ndef check_git_installed():\n    \"\"\"Check if git is installed and accessible.\"\"\"\n    try:\n        subprocess.run([\"git\", \"--version\"], check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n        return True\n    except (subprocess.SubprocessError, FileNotFoundError):\n        print(\"Error: Git is not installed or not in the PATH.\")\n        print(\"Please install Git from https://git-scm.com/downloads\")\n        return False\n\ndef get_github_token():\n    \"\"\"Get GitHub token from environment variables.\"\"\"\n    load_env_variables()\n    token = os.getenv(\"GITHUB_TOKEN\")\n    \n    if not token:\n        print(\"GitHub Personal Access Token not found in environment variables.\")\n        print(\"Please create a .env file with GITHUB_TOKEN=your_token\")\n        print(\"Create a token at: https://github.com/settings/tokens\")\n        print(\"Make sure it has 'repo' and 'workflow' permissions.\")\n        return None\n    \n    print(\"GitHub token loaded successfully!\")\n    return token\n\ndef get_user_info(token):\n    \"\"\"Get GitHub username using the token.\"\"\"\n    headers = {\n        \"Authorization\": f\"token {token}\",\n        \"Accept\": \"application/vnd.github.v3+json\"\n    }\n    \n    try:\n        response = requests.get(\"https://api.github.com/user\", headers=headers)\n        response.raise_for_status()\n        user_data = response.json()\n        return user_data\n    except Exception as e:\n        print(f\"Error getting GitHub user info: {e}\")\n        return None\n\ndef create_new_repository(token, username):\n    \"\"\"Create a new GitHub repository with a timestamp-based name.\"\"\"\n    headers = {\n        \"Authorization\": f\"token {token}\",\n        \"Accept\": \"application/vnd.github.v3+json\"\n    }\n    \n    timestamp = time.strftime(\"%Y%m%d%H%M%S\")\n    repo_name = f\"github-action-email-{timestamp}\"\n    \n    print(f\"Creating new repository: {repo_name}\")\n    \n    data = {\n        \"name\": repo_name,\n        \"description\": \"Repository for GitHub Actions with email step\",\n        \"private\": False,\n        \"auto_init\": True  # Initialize with a README\n    }\n    \n    try:\n        response = requests.post(\"https://api.github.com/user/repos\", headers=headers, json=data)\n        response.raise_for_status()\n        repo = response.json()\n        print(f\"Repository created: {repo['html_url']}\")\n        \n        # Wait a moment for GitHub to initialize the repository\n        print(\"Waiting for GitHub to initialize the repository...\")\n        time.sleep(3)\n        \n        return repo\n    except Exception as e:\n        print(f\"Error creating repository: {e}\")\n        return None\n\ndef create_workflow_file(email=\"24f2006438@ds.study.iitm.ac.in\"):\n    \"\"\"Create a GitHub Actions workflow file with the email in a step name.\"\"\"\n    workflow_dir = \".github/workflows\"\n    os.makedirs(workflow_dir, exist_ok=True)\n    \n    workflow_content = f\"\"\"name: GitHub Classroom Assignment Test\n\non:\n  push:\n    branches: [ main, master ]\n  pull_request:\n    branches: [ main, master ]\n  workflow_dispatch:\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n      \n      - name: Set up Python\n        uses: actions/setup-python@v2\n        with:\n          python-version: '3.9'\n          \n      - name: {email}\n        run: echo \"Hello, this step is named with my email address!\"\n        \n      - name: Run tests\n        run: |\n          python -m pip install --upgrade pip\n          if [ -f requirements.txt ]; then pip install -r requirements.txt; fi\n          echo \"Running tests for the assignment\"\n\"\"\"\n    \n    workflow_path = os.path.join(workflow_dir, \"classroom.yml\")\n    with open(workflow_path, \"w\") as f:\n        f.write(workflow_content)\n    \n    print(f\"Workflow file created at {workflow_path}\")\n    return workflow_path\n\ndef create_and_push_workflow(repo_url, token):\n    \"\"\"Create a workflow file and push it to the repository\"\"\"\n    # Create a temporary directory for our work\n    temp_dir = tempfile.mkdtemp(prefix=\"github_action_\")\n    \n    try:\n        print(f\"Cloning repository {repo_url}...\")\n        # Set the URL with token for authentication\n        auth_url = repo_url.replace(\"https://\", f\"https://{token}@\")\n        \n        # Clone the repository\n        subprocess.run([\"git\", \"clone\", auth_url, temp_dir], check=True, capture_output=True)\n        \n        # Change to the temp directory\n        original_dir = os.getcwd()\n        os.chdir(temp_dir)\n        \n        # Create the workflow file\n        workflow_path = create_workflow_file()\n        \n        # Configure Git\n        subprocess.run([\"git\", \"config\", \"user.name\", \"GitHub Action Bot\"], check=True)\n        subprocess.run([\"git\", \"config\", \"user.email\", \"noreply@github.com\"], check=True)\n        \n        # Add and commit the workflow file\n        subprocess.run([\"git\", \"add\", workflow_path], check=True)\n        subprocess.run([\"git\", \"commit\", \"-m\", \"Add GitHub Actions workflow with email in step name\"], check=True)\n        \n        # Push to GitHub\n        print(\"Pushing changes to GitHub...\")\n        subprocess.run([\"git\", \"push\"], check=True)\n        \n        print(\"Workflow file pushed successfully!\")\n        \n        # Change back to original directory\n        os.chdir(original_dir)\n        \n        return True\n    except Exception as e:\n        print(f\"Error during repo operations: {e}\")\n        # Change back to original directory if needed\n        if os.getcwd() != original_dir:\n            os.chdir(original_dir)\n        return False\n    finally:\n        # Clean up - wait a moment and then try to remove the temp directory\n        time.sleep(1)\n        try:\n            shutil.rmtree(temp_dir, ignore_errors=True)\n        except Exception as e:\n            print(f\"Note: Could not remove temporary directory {temp_dir}\")\n            # Instead of trying to delete the directory (which might cause issues),\n            # just notify the user but don't treat it as an error\n\ndef trigger_workflow(repo_full_name, token):\n    \"\"\"Trigger the workflow using GitHub API.\"\"\"\n    headers = {\n        \"Authorization\": f\"token {token}\",\n        \"Accept\": \"application/vnd.github.v3+json\"\n    }\n    \n    # Wait a moment for GitHub to register the workflow file\n    print(\"Waiting for GitHub to process the workflow file...\")\n    time.sleep(5)\n    \n    try:\n        # Get the workflow ID\n        response = requests.get(\n            f\"https://api.github.com/repos/{repo_full_name}/actions/workflows\", \n            headers=headers\n        )\n        response.raise_for_status()\n        workflows = response.json().get(\"workflows\", [])\n        \n        if not workflows:\n            print(\"No workflows found yet. It may take a moment to appear.\")\n            print(f\"You can check and manually trigger it at: https://github.com/{repo_full_name}/actions\")\n            return False\n        \n        workflow_id = None\n        for workflow in workflows:\n            if \"classroom.yml\" in workflow.get(\"path\", \"\"):\n                workflow_id = workflow[\"id\"]\n                break\n        \n        if not workflow_id:\n            print(\"Workflow not found. It may take a moment to appear.\")\n            print(f\"You can check and manually trigger it at: https://github.com/{repo_full_name}/actions\")\n            return False\n        \n        # Determine the default branch\n        branch_response = requests.get(\n            f\"https://api.github.com/repos/{repo_full_name}\",\n            headers=headers\n        )\n        branch_response.raise_for_status()\n        default_branch = branch_response.json().get(\"default_branch\", \"main\")\n        \n        # Trigger the workflow on the default branch\n        print(f\"Triggering workflow on branch '{default_branch}'...\")\n        trigger_response = requests.post(\n            f\"https://api.github.com/repos/{repo_full_name}/actions/workflows/{workflow_id}/dispatches\",\n            headers=headers,\n            json={\"ref\": default_branch}\n        )\n        \n        if trigger_response.status_code == 204:\n            print(\"Workflow triggered successfully!\")\n            print(f\"Check the run at: https://github.com/{repo_full_name}/actions\")\n            return True\n        else:\n            print(f\"Error triggering workflow: {trigger_response.status_code}\")\n            print(f\"You can manually trigger it at: https://github.com/{repo_full_name}/actions\")\n            return False\n    except Exception as e:\n        print(f\"Error during workflow trigger: {e}\")\n        print(f\"You can manually trigger it at: https://github.com/{repo_full_name}/actions\")\n        return False\n\ndef save_repository_url(repo_url):\n    \"\"\"Save the repository URL to a text file for easy access.\"\"\"\n    # Save to plain text file\n    with open('repository_url.txt', 'w') as f:\n        f.write(repo_url)\n    \n    # Save to a cleaner HTML file for easy copying\n    html_content = f\"\"\"<!DOCTYPE html>\n<html>\n<head>\n    <title>Repository URL</title>\n    <style>\n        body {{ font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px; }}\n        .url-box {{ background: #f5f5f5; padding: 15px; border-radius: 5px; margin: 20px 0; }}\n        .copy-btn {{ background: #4CAF50; color: white; border: none; padding: 10px 15px; \n                    border-radius: 4px; cursor: pointer; }}\n        h1 {{ color: #333; }}\n    </style>\n</head>\n<body>\n    <h1>Your GitHub Repository URL</h1>\n    <p>This is the URL you should provide when asked for your repository URL:</p>\n    \n    <div class=\"url-box\">\n        <code id=\"repo-url\">{repo_url}</code>\n    </div>\n    \n    <button class=\"copy-btn\" onclick=\"copyToClipboard()\">Copy URL</button>\n    \n    <script>\n        function copyToClipboard() {{\n            const text = document.getElementById('repo-url').innerText;\n            navigator.clipboard.writeText(text).then(() => {{\n                alert('URL copied to clipboard!');\n            }});\n        }}\n    </script>\n</body>\n</html>\n\"\"\"\n    \n    with open('repository_url.html', 'w') as f:\n        f.write(html_content)\n    \n    print(f\"Repository URL saved to repository_url.txt and repository_url.html\")\n\ndef main():\n    \"\"\"Main function to create and trigger a GitHub action.\"\"\"\n    print(\"GitHub Action Creator\")\n    print(\"=\" * 50)\n    \n    # Check if git is installed\n    if not check_git_installed():\n        return\n    \n    # Get GitHub token\n    token = get_github_token()\n    if not token:\n        return\n    \n    # Get user info\n    user_info = get_user_info(token)\n    if not user_info:\n        return\n    \n    username = user_info[\"login\"]\n    print(f\"Authenticated as: {username}\")\n    \n    # Always create a new repository\n    repo = create_new_repository(token, username)\n    if not repo:\n        return\n    \n    repo_url = repo[\"html_url\"]\n    repo_full_name = repo[\"full_name\"]\n    \n    # Create and push workflow file\n    if not create_and_push_workflow(repo_url, token):\n        return\n    \n    # Trigger the workflow\n    trigger_workflow(repo_full_name, token)\n    \n    # Save the repository URL to a file\n    save_repository_url(repo_url)\n    \n    print(\"\\nSummary:\")\n    print(\"=\" * 50)\n    print(f\"Repository URL: {repo_url}\")\n    print(f\"GitHub Actions URL: {repo_url}/actions\")\n    print(\"\\nThe workflow contains a step named with your email: 24f2006438@ds.study.iitm.ac.in\")\n    print(\"You can check the most recent action run by visiting the Actions tab in your repository.\")\n    print(f\"\\nWhen asked for the repository URL, provide: {repo_url}\")\n    print(\"\\nThis URL has been saved to repository_url.txt for easy reference.\")\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
        "file": "E://data science tool//GA2//eighth.py",
        "question": null,
        "parameter": null,
        "code": "import os\nimport sys\nimport subprocess\nimport tempfile\nimport time\nimport webbrowser\nimport json\nimport random\nimport argparse\nfrom pathlib import Path\nfrom dotenv import load_dotenv\n\ndef parse_arguments():\n    \"\"\"Parse command line arguments.\"\"\"\n    parser = argparse.ArgumentParser(description='Create a Docker image with a specific tag')\n    parser.add_argument('--tag', type=str, default=\"24f2006438\", \n                        help='Tag to use for the Docker image (default: 24f2006438)')\n    return parser.parse_args()\n\ndef load_env_variables():\n    \"\"\"Load environment variables from .env file\"\"\"\n    # Look for .env file in multiple locations\n    search_paths = [\n        '.env',  # Current directory\n        os.path.join(os.path.dirname(os.path.abspath(__file__)), '.env'),  # Script directory\n        os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), '.env'),  # Parent directory\n    ]\n    \n    for env_path in search_paths:\n        if os.path.exists(env_path):\n            print(f\"Loading environment variables from {env_path}\")\n            load_dotenv(env_path)\n            return True\n    \n    print(\"No .env file found. Creating one with your Docker Hub credentials.\")\n    return False\n\ndef create_env_file():\n    \"\"\"Create .env file with user input\"\"\"\n    username = input(\"Enter your Docker Hub username: \")\n    password = input(\"Enter your Docker Hub password: \")\n    \n    with open('.env', 'w') as f:\n        f.write(f\"DOCKERHUB_USERNAME={username}\\n\")\n        f.write(f\"DOCKERHUB_PASSWORD={password}\\n\")\n    \n    print(\"Created .env file with Docker Hub credentials\")\n    load_dotenv('.env')\n    return username, password\n\ndef check_docker_status():\n    \"\"\"Check if Docker is installed and try to determine if it's running.\"\"\"\n    try:\n        # Check if Docker is installed\n        version_result = subprocess.run(\n            [\"docker\", \"--version\"], \n            stdout=subprocess.PIPE, \n            stderr=subprocess.PIPE, \n            text=True\n        )\n        if version_result.returncode == 0:\n            print(f\"Docker is installed: {version_result.stdout.strip()}\")\n            \n            # Try to check if Docker is running\n            info_result = subprocess.run(\n                [\"docker\", \"info\"], \n                stdout=subprocess.PIPE, \n                stderr=subprocess.PIPE, \n                text=True\n            )\n            if info_result.returncode == 0:\n                print(\"Docker is running correctly.\")\n                return True\n            else:\n                print(\"Docker is installed but not running properly.\")\n                return False\n        else:\n            print(\"Docker does not appear to be installed.\")\n            return False\n    except (subprocess.SubprocessError, FileNotFoundError):\n        print(\"Docker is not installed or not in the PATH.\")\n        return False\n\ndef create_dockerfile_locally(tag):\n    \"\"\"Create a Dockerfile and app.py in a local directory.\"\"\"\n    # Create a directory for the Docker build files\n    docker_dir = os.path.join(os.getcwd(), \"docker-build\")\n    os.makedirs(docker_dir, exist_ok=True)\n    \n    dockerfile_content = f\"\"\"FROM python:3.9-slim\n\n# Add metadata\nLABEL maintainer=\"24f2006438@ds.study.iitm.ac.in\"\nLABEL description=\"Simple Python image for IITM assignment\"\nLABEL tag=\"{tag}\"\n\n# Create working directory\nWORKDIR /app\n\n# Copy a simple Python script\nCOPY app.py .\n\n# Set the command to run the script\nCMD [\"python\", \"app.py\"]\n\"\"\"\n    \n    app_content = f\"\"\"\nimport time\nprint(\"Hello from the IITM BS Degree Docker assignment!\")\nprint(\"This container was created with tag: {tag}\")\ntime.sleep(60)  # Keep container running for a minute\n\"\"\"\n    \n    # Write the Dockerfile\n    with open(os.path.join(docker_dir, \"Dockerfile\"), \"w\") as f:\n        f.write(dockerfile_content)\n    \n    # Write a simple Python app\n    with open(os.path.join(docker_dir, \"app.py\"), \"w\") as f:\n        f.write(app_content)\n    \n    print(f\"Created Dockerfile and app.py in {docker_dir}\")\n    return docker_dir\n\ndef save_docker_url(url):\n    \"\"\"Save the Docker Hub URL to files.\"\"\"\n    with open(\"docker_url.txt\", \"w\") as f:\n        f.write(url)\n    \n    with open(\"submission_docker_url.txt\", \"w\") as f:\n        f.write(f\"Docker image URL: {url}\")\n    \n    print(f\"Docker Hub URL saved to docker_url.txt and submission_docker_url.txt\")\n\ndef generate_docker_hub_url(username):\n    \"\"\"Generate a valid Docker Hub URL for the assignment.\"\"\"\n    timestamp = time.strftime(\"%Y%m%d%H%M%S\")\n    image_name = f\"iitm-assignment-{timestamp}\"\n    \n    # Format for Docker Hub repositories changed - use this format\n    # This is the standard format for Docker Hub repository URLs\n    repo_url = f\"https://hub.docker.com/r/{username}/{image_name}\"\n    return repo_url, image_name\n\ndef show_manual_instructions(username, image_name, tag, docker_dir):\n    \"\"\"Show instructions for manual Docker build and push.\"\"\"\n    print(\"\\n\" + \"=\" * 80)\n    print(\"MANUAL DOCKER INSTRUCTIONS\")\n    print(\"=\" * 80)\n    print(\"To complete this assignment when Docker is working properly:\")\n    \n    print(\"\\n1. Start Docker Desktop and make sure it's running\")\n    \n    print(\"\\n2. Open a command prompt and navigate to the docker-build directory:\")\n    print(f\"   cd {os.path.abspath(docker_dir)}\")\n    \n    print(\"\\n3. Log in to Docker Hub:\")\n    print(f\"   docker login --username {username}\")\n    \n    print(\"\\n4. Build the Docker image:\")\n    print(f\"   docker build -t {username}/{image_name}:{tag} -t {username}/{image_name}:latest .\")\n    \n    print(\"\\n5. Push the Docker image to Docker Hub:\")\n    print(f\"   docker push {username}/{image_name}:{tag}\")\n    print(f\"   docker push {username}/{image_name}:latest\")\n    \n    print(\"\\n6. Your Docker Hub repository URL will be:\")\n    print(f\"   https://hub.docker.com/r/{username}/{image_name}\")\n    print(\"=\" * 80)\n\ndef main():\n    \"\"\"Main function to create and push a Docker image.\"\"\"\n    # Parse command line arguments\n    args = parse_arguments()\n    tag = args.tag\n    \n    print(\"Docker Image Creator\")\n    print(\"=\" * 50)\n    print(f\"Using tag: {tag}\")\n    \n    # Check if Docker is installed and running\n    docker_running = check_docker_status()\n    \n    # Load or create environment variables\n    if not load_env_variables():\n        username, password = create_env_file()\n    else:\n        username = os.getenv(\"DOCKERHUB_USERNAME\")\n        password = os.getenv(\"DOCKERHUB_PASSWORD\")\n        \n        if not username or not password:\n            username, password = create_env_file()\n    \n    # Create Dockerfile locally anyway\n    docker_dir = create_dockerfile_locally(tag)\n    \n    # Create unique image name with timestamp and generate URL\n    timestamp = time.strftime(\"%Y%m%d%H%M%S\")\n    image_name = f\"iitm-assignment-{timestamp}\"\n    \n    # Generate the Docker Hub URL\n    repo_url, image_name = generate_docker_hub_url(username)\n    \n    if docker_running:\n        print(\"\\nDocker is running. You can build and push the image manually.\")\n        show_manual_instructions(username, image_name, tag, docker_dir)\n    else:\n        print(\"\\nDocker is not running properly, but we've generated the URL and files you need.\")\n        print(\"When Docker is working, follow the instructions below.\")\n        show_manual_instructions(username, image_name, tag, docker_dir)\n    \n    # Save the URL to files\n    save_docker_url(repo_url)\n    \n    print(\"\\nSummary:\")\n    print(\"=\" * 50)\n    print(f\"Image name: {username}/{image_name}\")\n    print(f\"Tag: {tag}\")\n    print(f\"Docker Hub URL: {repo_url}\")\n    \n    print(\"\\nWhen asked for the Docker image URL, provide:\")\n    print(repo_url)\n    print(\"\\nThis URL has been saved to docker_url.txt and submission_docker_url.txt\")\n    \n    # Option to open Docker Hub\n    open_browser = input(\"\\nWould you like to open Docker Hub in your browser? (y/n): \").lower() == 'y'\n    if open_browser:\n        webbrowser.open(f\"https://hub.docker.com/u/{username}\")\n    \n    return repo_url\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
        "file": "E://data science tool//GA2//ninth.py",
        "question": null,
        "parameter": null,
        "code": "import os\nimport csv\nimport uvicorn\nimport argparse\nfrom typing import List, Dict, Optional\nfrom fastapi import FastAPI, Query\nfrom fastapi.middleware.cors import CORSMiddleware\n\n# Parse command line arguments\ndef parse_arguments():\n    parser = argparse.ArgumentParser(description='Start a FastAPI server to serve student data from a CSV file')\n    parser.add_argument('--file', type=str, default='E:\\\\data science tool\\\\GA2\\\\q-fastapi.csv',\n                      help='Path to the CSV file (default: E:\\\\data science tool\\\\GA2\\\\q-fastapi.csv)')\n    parser.add_argument('--columns', type=int, default=2,\n                      help='Number of columns in the CSV file (default: 2)')\n    parser.add_argument('--host', type=str, default='127.0.0.1',\n                      help='Host to run the server on (default: 127.0.0.1)')\n    parser.add_argument('--port', type=int, default=8000,\n                      help='Port to run the server on (default: 8000)')\n    return parser.parse_args()\n\n# Create FastAPI app\napp = FastAPI(title=\"Student Data API\")\n\n# Add CORS middleware to allow requests from any origin\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"*\"],  # Allow all origins\n    allow_credentials=True,\n    allow_methods=[\"GET\"],  # Only allow GET requests\n    allow_headers=[\"*\"],\n)\n\n# Global variable to store the data\nstudents_data = []\ncsv_file_path = 'E:\\\\data science tool\\\\GA2\\\\q-fastapi.csv'\n\ndef load_data(file_path: str, num_columns: int = 2):\n    \"\"\"Load data from CSV file\"\"\"\n    global students_data\n    students_data = []\n    \n    if not os.path.exists(file_path):\n        print(f\"Error: File '{file_path}' not found.\")\n        return False\n    \n    try:\n        with open(file_path, 'r', newline='') as csvfile:\n            csv_reader = csv.reader(csvfile)\n            \n            # Read header row\n            header = next(csv_reader, None)\n            if not header or len(header) < num_columns:\n                print(f\"Error: CSV file does not have enough columns. Expected {num_columns}, got {len(header) if header else 0}.\")\n                return False\n            \n            # Use the first two column names (or default names if headers are missing)\n            column_names = [\n                header[0] if header and len(header) > 0 else \"studentId\",\n                header[1] if header and len(header) > 1 else \"class\"\n            ]\n            \n            # Read data rows\n            for row in csv_reader:\n                if len(row) >= num_columns:\n                    student = {\n                        column_names[0]: try_int(row[0]),  # Convert studentId to integer if possible\n                        column_names[1]: row[1]\n                    }\n                    students_data.append(student)\n        \n        print(f\"Loaded {len(students_data)} students from {file_path}\")\n        return True\n    \n    except Exception as e:\n        print(f\"Error loading data: {e}\")\n        return False\n\ndef try_int(value):\n    \"\"\"Try to convert a value to integer, return original value if not possible\"\"\"\n    try:\n        return int(value)\n    except (ValueError, TypeError):\n        return value\n\n@app.get(\"/api\")\nasync def get_students(class_filter: Optional[List[str]] = Query(None, alias=\"class\")):\n    \"\"\"\n    Get students data, optionally filtered by class\n    \n    Parameters:\n    - class_filter: Optional list of classes to filter by\n    \n    Returns:\n    - Dictionary with students array\n    \"\"\"\n    if not class_filter:\n        # Return all students if no class filter is provided\n        return {\"students\": students_data}\n    \n    # Filter students by class\n    filtered_students = [\n        student for student in students_data \n        if student.get(\"class\") in class_filter\n    ]\n    \n    return {\"students\": filtered_students}\n\n@app.get(\"/\")\nasync def root():\n    \"\"\"Root endpoint with usage information\"\"\"\n    return {\n        \"message\": \"Student Data API\",\n        \"usage\": {\n            \"all_students\": \"/api\",\n            \"filtered_by_class\": \"/api?class=1A\",\n            \"filtered_by_multiple_classes\": \"/api?class=1A&class=1B\"\n        },\n        \"loaded_students_count\": len(students_data)\n    }\n\ndef start_server():\n    \"\"\"Main function to start the FastAPI server\"\"\"\n    args = parse_arguments()\n    \n    # Update global variables\n    global csv_file_path\n    csv_file_path = args.file\n    \n    # Load data from CSV file\n    if not load_data(args.file, args.columns):\n        print(f\"Failed to load data from {args.file}. Exiting...\")\n        return\n    \n    # Print the API URL for convenience\n    api_url = f\"http://{args.host}:{args.port}/api\"\n    print(\"\\n\" + \"=\" * 50)\n    print(f\"API URL endpoint: {api_url}\")\n    print(\"=\" * 50)\n    \n    # Save the API URL to a file\n    with open(\"api_url.txt\", \"w\") as f:\n        f.write(api_url)\n    print(f\"API URL saved to api_url.txt\")\n    \n    # Start the server\n    uvicorn.run(app, host=args.host, port=args.port)\n\nif __name__ == \"__main__\":\n    start_server()"
    },
    {
        "file": "E://data science tool//GA2//tenth.py",
        "question": null,
        "parameter": null,
        "code": "import os\nimport sys\nimport subprocess\nimport platform\nimport time\nimport requests\nimport zipfile\nimport io\nimport shutil\nimport signal\nimport atexit\nfrom pathlib import Path\nimport webbrowser\nfrom threading import Thread\nfrom dotenv import load_dotenv\n\n# Configuration \nLLAMAFILE_VERSION = \"0.7.0\"\nMODEL_NAME = \"Llama-3.2-1B-Instruct.Q6_K.llamafile\"\nMODEL_URL = \"https://huggingface.co/Mozilla/llava-v1.5-7b-llamafile/resolve/main/llava-v1.5-7b-q4.llamafile?download=true\"\nload_dotenv()\nNGROK_AUTH_TOKEN_ENV = \"NGROK_AUTH_TOKEN\"\nMODEL_DIR = \"models\"  # Directory to store downloaded models\n\n# Platform detection\nsystem = platform.system()\nis_windows = system == \"Windows\"\nis_macos = system == \"Darwin\"\nis_linux = system == \"Linux\"\n\n# File extension for executable\nexe_ext = \".exe\" if is_windows else \"\"\n\ndef print_section(title):\n    \"\"\"Print a section title with formatting.\"\"\"\n    print(\"\\n\" + \"=\" * 60)\n    print(f\" {title}\")\n    print(\"=\" * 60)\n\ndef check_system_for_model():\n    \"\"\"Check if the model file is already available on the system.\"\"\"\n    print_section(\"Checking for Model File\")\n    \n    # Check current directory\n    if os.path.exists(MODEL_NAME):\n        print(f\"\u2713 Found model in current directory: {os.path.abspath(MODEL_NAME)}\")\n        return os.path.abspath(MODEL_NAME)\n    \n    # Check models directory\n    model_path = os.path.join(MODEL_DIR, MODEL_NAME)\n    if os.path.exists(model_path):\n        print(f\"\u2713 Found model in models directory: {os.path.abspath(model_path)}\")\n        return os.path.abspath(model_path)\n    \n    # Check Downloads folder\n    downloads_dir = os.path.join(os.path.expanduser(\"~\"), \"Downloads\")\n    downloads_path = os.path.join(downloads_dir, MODEL_NAME)\n    if os.path.exists(downloads_path):\n        print(f\"\u2713 Found model in Downloads folder: {downloads_path}\")\n        return downloads_path\n    \n    # If we reach here, the model wasn't found\n    print(\"\u2717 Model file not found on system.\")\n    return None\n\ndef download_model():\n    \"\"\"Download the model file.\"\"\"\n    print_section(f\"Downloading {MODEL_NAME}\")\n    \n    # Create models directory if it doesn't exist\n    os.makedirs(MODEL_DIR, exist_ok=True)\n    \n    model_path = os.path.join(MODEL_DIR, MODEL_NAME)\n    \n    try:\n        print(f\"Downloading from: {MODEL_URL}\")\n        # Download with a progress indicator\n        response = requests.get(MODEL_URL, stream=True)\n        response.raise_for_status()\n        \n        # Get total size\n        total_size = int(response.headers.get('content-length', 0))\n        \n        # Download and save\n        with open(model_path, 'wb') as f:\n            downloaded = 0\n            for chunk in response.iter_content(chunk_size=8192):\n                if chunk:\n                    f.write(chunk)\n                    downloaded += len(chunk)\n                    \n                    # Print progress\n                    progress = (downloaded / total_size) * 100 if total_size > 0 else 0\n                    sys.stdout.write(f\"\\rDownloading: {progress:.1f}% ({downloaded/(1024*1024):.1f} MB / {total_size/(1024*1024):.1f} MB)\")\n                    sys.stdout.flush()\n        \n        # Make it executable on Unix-like systems\n        if not is_windows:\n            os.chmod(model_path, 0o755)\n        \n        print(f\"\\n\u2713 Model downloaded to {model_path}\")\n        return model_path\n    \n    except Exception as e:\n        print(f\"\\n\u2717 Failed to download model: {e}\")\n        return None\n\ndef check_dependencies():\n    \"\"\"Check if required dependencies are installed.\"\"\"\n    print_section(\"Checking Dependencies\")\n    \n    # Check if ngrok is installed\n    try:\n        result = subprocess.run(\n            [\"ngrok\", \"version\"], \n            stdout=subprocess.PIPE, \n            stderr=subprocess.PIPE, \n            text=True\n        )\n        print(\"\u2713 ngrok is installed.\")\n    except (subprocess.SubprocessError, FileNotFoundError):\n        print(\"\u2717 ngrok is not installed or not in PATH.\")\n        install_ngrok = input(\"Would you like to download ngrok? (y/n): \").lower() == 'y'\n        if install_ngrok:\n            download_ngrok()\n        else:\n            print(\"Please install ngrok from https://ngrok.com/download\")\n            sys.exit(1)\n    \n    # Check for ngrok auth token in environment\n    ngrok_token = os.environ.get(NGROK_AUTH_TOKEN_ENV)\n    if not ngrok_token:\n        print(\"\u2717 NGROK_AUTH_TOKEN not found in environment variables.\")\n        set_ngrok_token()\n    else:\n        print(\"\u2713 NGROK_AUTH_TOKEN found in environment variables.\")\n\ndef set_ngrok_token():\n    \"\"\"Set ngrok authentication token.\"\"\"\n    print(\"\\nYou need to provide an ngrok authentication token.\")\n    print(\"If you don't have one, sign up at https://ngrok.com/ and get a token.\")\n    \n    token = input(\"Enter your ngrok auth token: \").strip()\n    \n    if token:\n        # Try to configure ngrok with the provided token\n        try:\n            subprocess.run(\n                [\"ngrok\", \"config\", \"add-authtoken\", token],\n                check=True,\n                stdout=subprocess.PIPE,\n                stderr=subprocess.PIPE\n            )\n            print(\"\u2713 ngrok token configured successfully.\")\n            \n            # Also set it in the environment for this session\n            os.environ[NGROK_AUTH_TOKEN_ENV] = token\n        except subprocess.SubprocessError:\n            print(\"\u2717 Failed to configure ngrok token.\")\n            print(\"Please configure it manually with: ngrok config add-authtoken YOUR_TOKEN\")\n    else:\n        print(\"No token provided. You'll need to configure ngrok manually.\")\n\ndef download_ngrok():\n    \"\"\"Download and install ngrok.\"\"\"\n    print_section(\"Downloading ngrok\")\n    \n    # Determine the correct download URL based on the platform\n    if is_windows:\n        download_url = \"https://bin.equinox.io/c/bNyj1mQVY4c/ngrok-v3-stable-windows-amd64.zip\"\n    elif is_macos:\n        if platform.machine() == \"arm64\":  # Apple Silicon\n            download_url = \"https://bin.equinox.io/c/bNyj1mQVY4c/ngrok-v3-stable-darwin-arm64.zip\"\n        else:  # Intel Mac\n            download_url = \"https://bin.equinox.io/c/bNyj1mQVY4c/ngrok-v3-stable-darwin-amd64.zip\"\n    elif is_linux:\n        if platform.machine() == \"aarch64\":  # ARM Linux\n            download_url = \"https://bin.equinox.io/c/bNyj1mQVY4c/ngrok-v3-stable-linux-arm64.zip\"\n        else:  # x86_64 Linux\n            download_url = \"https://bin.equinox.io/c/bNyj1mQVY4c/ngrok-v3-stable-linux-amd64.zip\"\n    else:\n        print(f\"Unsupported platform: {system}\")\n        return False\n    \n    print(f\"Downloading ngrok from {download_url}...\")\n    \n    try:\n        response = requests.get(download_url)\n        response.raise_for_status()\n        \n        # Extract the zip file\n        with zipfile.ZipFile(io.BytesIO(response.content)) as zip_file:\n            # Determine where to extract ngrok\n            if is_windows:\n                # On Windows, try to extract to a directory in PATH\n                ngrok_path = None\n                for path_dir in os.environ.get(\"PATH\", \"\").split(os.pathsep):\n                    if os.access(path_dir, os.W_OK):\n                        ngrok_path = os.path.join(path_dir, \"ngrok.exe\")\n                        break\n                \n                if not ngrok_path:\n                    # If no writable PATH directory, extract to current directory\n                    ngrok_path = os.path.join(os.getcwd(), \"ngrok.exe\")\n                \n                # Extract ngrok.exe\n                with zip_file.open(\"ngrok.exe\") as src, open(ngrok_path, \"wb\") as dest:\n                    shutil.copyfileobj(src, dest)\n                \n                print(f\"\u2713 ngrok extracted to {ngrok_path}\")\n            else:\n                # On Unix-like systems, extract to /usr/local/bin if possible, or current directory\n                if os.access(\"/usr/local/bin\", os.W_OK):\n                    ngrok_path = \"/usr/local/bin/ngrok\"\n                else:\n                    ngrok_path = os.path.join(os.getcwd(), \"ngrok\")\n                \n                # Extract ngrok\n                with zip_file.open(\"ngrok\") as src, open(ngrok_path, \"wb\") as dest:\n                    shutil.copyfileobj(src, dest)\n                \n                # Make it executable\n                os.chmod(ngrok_path, 0o755)\n                \n                print(f\"\u2713 ngrok extracted to {ngrok_path}\")\n        \n        return True\n    \n    except Exception as e:\n        print(f\"\u2717 Failed to download or extract ngrok: {e}\")\n        return False\n\ndef run_llamafile(model_path):\n    \"\"\"Run the model with llamafile.\"\"\"\n    print_section(\"Starting LLaMA Model Server\")\n    \n    if not os.path.exists(model_path):\n        print(f\"\u2717 Model file not found at {model_path}\")\n        return None\n    \n    # Check if the model is already a llamafile\n    is_llamafile = False\n    if \"llamafile\" in model_path.lower():\n        # Make it executable on Unix-like systems\n        if not is_windows:\n            os.chmod(model_path, 0o755)\n        is_llamafile = True\n    \n    try:\n        if is_llamafile:\n            # Run the model directly as it's a llamafile\n            cmd = [model_path, \"--server\", \"--port\", \"8080\", \"--host\", \"0.0.0.0\"]\n        else:\n            # Command to run the model with llamafile\n            llamafile_path = os.path.join(\"bin\", f\"llamafile{exe_ext}\")\n            if not os.path.exists(llamafile_path):\n                print(f\"\u2717 llamafile not found at {llamafile_path}\")\n                return None\n            cmd = [llamafile_path, \"-m\", model_path, \"--server\", \"--port\", \"8080\", \"--host\", \"0.0.0.0\"]\n        \n        print(f\"Starting llamafile server with command: {' '.join(cmd)}\")\n        \n        # Start the process\n        process = subprocess.Popen(\n            cmd, \n            stdout=subprocess.PIPE, \n            stderr=subprocess.PIPE, \n            text=True,\n            bufsize=1,  # Line buffered\n            universal_newlines=True\n        )\n        \n        # Register cleanup handler to terminate the process on exit\n        atexit.register(lambda: terminate_process(process))\n        \n        # Wait for the server to start up\n        print(\"Waiting for llamafile server to start...\")\n        \n        # Read output in a separate thread to prevent blocking\n        def print_output():\n            for line in process.stdout:\n                print(f\"LLaMA: {line.strip()}\")\n        \n        Thread(target=print_output, daemon=True).start()\n        \n        # Give it some time to start\n        time.sleep(10)\n        \n        # Check if the process is still running\n        if process.poll() is not None:\n            print(\"\u2717 llamafile server failed to start\")\n            # Get any error output\n            error = process.stderr.read()\n            print(f\"Error: {error}\")\n            return None\n        \n        print(\"\u2713 llamafile server started on http://localhost:8080\")\n        return process\n    \n    except Exception as e:\n        print(f\"\u2717 Failed to start llamafile server: {e}\")\n        return None\n\ndef create_ngrok_tunnel():\n    \"\"\"Create an ngrok tunnel to the llamafile server.\"\"\"\n    print_section(\"Creating ngrok Tunnel\")\n    \n    try:\n        # Create tunnel to port 8080\n        cmd = [\"ngrok\", \"http\", \"8080\"]\n        \n        # Start ngrok process\n        ngrok_process = subprocess.Popen(\n            cmd,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n            text=True,\n            bufsize=1,\n            universal_newlines=True\n        )\n        \n        # Register cleanup handler\n        atexit.register(lambda: terminate_process(ngrok_process))\n        \n        print(\"Waiting for ngrok tunnel to be established...\")\n        time.sleep(5)\n        \n        # Check if ngrok is still running\n        if ngrok_process.poll() is not None:\n            print(\"\u2717 ngrok failed to start\")\n            error = ngrok_process.stderr.read()\n            print(f\"Error: {error}\")\n            return None\n        \n        # Get the public URL from ngrok API\n        try:\n            response = requests.get(\"http://localhost:4040/api/tunnels\")\n            response.raise_for_status()\n            tunnels = response.json()[\"tunnels\"]\n            \n            if tunnels:\n                for tunnel in tunnels:\n                    if tunnel[\"proto\"] == \"https\":\n                        public_url = tunnel[\"public_url\"]\n                        print(f\"\u2713 ngrok tunnel created: {public_url}\")\n                        \n                        # Save the URL to a file\n                        with open(\"ngrok_url.txt\", \"w\") as f:\n                            f.write(public_url)\n                        print(\"ngrok URL saved to ngrok_url.txt\")\n                        \n                        return public_url, ngrok_process\n            \n            print(\"\u2717 No ngrok tunnels found\")\n            return None\n            \n        except Exception as e:\n            print(f\"\u2717 Failed to get ngrok tunnel URL: {e}\")\n            return None\n    \n    except Exception as e:\n        print(f\"\u2717 Failed to create ngrok tunnel: {e}\")\n        return None\n\ndef terminate_process(process):\n    \"\"\"Safely terminate a process.\"\"\"\n    if process and process.poll() is None:\n        print(f\"Terminating process PID {process.pid}...\")\n        try:\n            if is_windows:\n                # On Windows, use taskkill to ensure the process and its children are killed\n                subprocess.run([\"taskkill\", \"/F\", \"/T\", \"/PID\", str(process.pid)], \n                              stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n            else:\n                # On Unix, send SIGTERM\n                process.terminate()\n                process.wait(timeout=5)\n        except Exception as e:\n            print(f\"Error terminating process: {e}\")\n            # Force kill if termination fails\n            try:\n                process.kill()\n            except:\n                pass\n\ndef main():\n    \"\"\"Main function to run the model and create an ngrok tunnel.\"\"\"\n    print_section(\"LLaMA Model Server with ngrok Tunnel\")\n    print(f\"Model: {MODEL_NAME}\")\n    \n    # Check dependencies\n    check_dependencies()\n    \n    # First check if the model is already on the system\n    model_path = check_system_for_model()\n    \n    # If not found, download it\n    if not model_path:\n        print(f\"Model not found. Downloading {MODEL_NAME}...\")\n        model_path = download_model()\n        \n        if not model_path:\n            print(\"\u2717 Failed to get model. Exiting.\")\n            return\n    \n    # Run llamafile server\n    llamafile_process = run_llamafile(model_path)\n    if not llamafile_process:\n        print(\"\u2717 Failed to start llamafile server. Exiting.\")\n        return\n    \n    # Create ngrok tunnel\n    tunnel_info = create_ngrok_tunnel()\n    if not tunnel_info:\n        print(\"\u2717 Failed to create ngrok tunnel. Exiting.\")\n        terminate_process(llamafile_process)\n        return\n    \n    public_url, ngrok_process = tunnel_info\n    \n    # Print summary\n    print_section(\"Summary\")\n    print(f\"Model: {MODEL_NAME}\")\n    print(f\"Local server: http://localhost:8080\")\n    print(f\"ngrok tunnel: {public_url}\")\n    print(\"\\nWhen asked for the ngrok URL, provide:\")\n    print(public_url)\n    \n    # Open browser\n    open_browser = input(\"\\nWould you like to open the web UI in your browser? (y/n): \").lower() == 'y'\n    if open_browser:\n        webbrowser.open(public_url)\n    \n    # Keep the script running until interrupted\n    print(\"\\nPress Ctrl+C to stop the server and tunnel...\")\n    try:\n        while True:\n            time.sleep(1)\n            \n            # Check if processes are still running\n            if llamafile_process.poll() is not None:\n                print(\"\u2717 llamafile server has stopped\")\n                break\n            \n            if ngrok_process.poll() is not None:\n                print(\"\u2717 ngrok tunnel has stopped\")\n                break\n    \n    except KeyboardInterrupt:\n        print(\"\\nShutting down...\")\n    finally:\n        # Clean up processes\n        terminate_process(llamafile_process)\n        terminate_process(ngrok_process)\n        print(\"All processes terminated\")\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
        "file": "E://data science tool//GA3//first.py",
        "question": null,
        "parameter": null,
        "code": "import httpx\n\ndef analyze_sentiment():\n    \"\"\"\n    Sends a POST request to OpenAI's API to analyze sentiment of a text.\n    Categorizes the sentiment as GOOD, BAD, or NEUTRAL.\n    \"\"\"\n    # OpenAI API endpoint for chat completions\n    url = \"https://api.openai.com/v1/chat/completions\"\n    \n    # Dummy API key for testing\n    api_key = \"dummy_api_key_for_testing_purposes_only\"\n    \n    # Target text for sentiment analysis\n    target_text = \"\"\"This test is crucial for DataSentinel Inc. as it validates both the API integration \n    and the correctness of message formatting in a controlled environment. Once verified, the same \n    mechanism will be used to process genuine customer feedback, ensuring that the sentiment analysis \n    module reliably categorizes data as GOOD, BAD, or NEUTRAL. This reliability is essential for \n    maintaining high operational standards and swift response times in real-world applications.\"\"\"\n    \n    # Headers for the API request\n    headers = {\n        \"Authorization\": f\"Bearer {api_key}\",\n        \"Content-Type\": \"application/json\"\n    }\n    \n    # Request body with system message and user message\n    request_body = {\n        \"model\": \"gpt-4o-mini\",\n        \"messages\": [\n            {\n                \"role\": \"system\",\n                \"content\": \"You are a sentiment analysis assistant. Analyze the sentiment of the following text and classify it as either GOOD, BAD, or NEUTRAL. Provide only the classification without any explanation.\"\n            },\n            {\n                \"role\": \"user\",\n                \"content\": target_text\n            }\n        ],\n        \"temperature\": 0.7\n    }\n    \n    try:\n        # Send POST request to OpenAI API\n        response = httpx.post(url, json=request_body, headers=headers)\n        \n        # Check if request was successful\n        response.raise_for_status()\n        \n        # Parse and return the response\n        result = response.json()\n        sentiment = result.get(\"choices\", [{}])[0].get(\"message\", {}).get(\"content\", \"No result\")\n        \n        print(f\"Sentiment Analysis Result: {sentiment}\")\n        return sentiment\n        \n    except Exception as e:\n        print(f\"Error during sentiment analysis: {str(e)}\")\n        return None\n\nif __name__ == \"__main__\":\n    analyze_sentiment()"
    },
    {
        "file": "E://data science tool//GA3//second.py",
        "question": null,
        "parameter": null,
        "code": "import tiktoken\n\ndef count_tokens(text):\n    \"\"\"\n    Counts the number of tokens in the specified text using OpenAI's tokenizer.\n    This helps LexiSolve Inc. to measure token usage for typical prompts.\n    \n    Args:\n        text (str): The text to analyze for token count\n        \n    Returns:\n        int: Number of tokens in the text, or None if an error occurs\n    \"\"\"\n    try:\n        # Initialize the tokenizer for GPT-4o-mini\n        # cl100k_base is used for the newer GPT-4o models\n        encoding = tiktoken.get_encoding(\"cl100k_base\")\n        \n        # Encode the text to get tokens\n        tokens = encoding.encode(text)\n        \n        # Count the number of tokens\n        token_count = len(tokens)\n        \n        # print(f\"Text: {text[:50]}...\")\n        # print(f\"Number of tokens: {token_count}\")\n        \n        # Display token distribution for analysis\n        unique_tokens = set(tokens)\n        # print(f\"Number of unique tokens: {len(unique_tokens)}\")\n        \n        # Optional: Visualize some tokens for debugging\n        # print(\"\\nSample token IDs (first 10):\")\n        for i, token in enumerate(tokens[:10]):\n            token_bytes = encoding.decode_single_token_bytes(token)\n            token_text = token_bytes.decode('utf-8', errors='replace')\n            # print(f\"Token {i+1}: ID={token}, Text='{token_text}'\")\n        \n        return token_count\n        \n    except Exception as e:\n        print(f\"Error calculating tokens: {str(e)}\")\n        return None\n\ndef simulate_token_cost(token_count, model=\"gpt-4o-mini\"):\n    \"\"\"\n    Simulates the cost of processing the tokens based on OpenAI's pricing.\n    \n    Args:\n        token_count: Number of tokens\n        model: The model being used\n    \n    Returns:\n        Estimated cost in USD\n    \"\"\"\n    # Example pricing (as of knowledge cutoff date)\n    # You would need to update these with current pricing\n    model_pricing = {\n        \"gpt-4o-mini\": {\n            \"input\": 0.00015, # per 1K tokens\n            \"output\": 0.0006  # per 1K tokens\n        }\n    }\n    \n    if model not in model_pricing:\n        # print(f\"Pricing for {model} not available\")\n        return None\n    \n    # Calculate cost for input tokens only (since this is the question)\n    input_cost = (token_count / 1000) * model_pricing[model][\"input\"]\n    \n    # print(f\"\\nEstimated cost for {token_count} input tokens with {model}: ${input_cost:.6f}\")\n    return input_cost\n\ndef main():\n    # Example text from the problem statement\n    example_text = \"\"\"List only the valid English words from these: 67llI, W56, 857xUSfYl, wnYpo5, 6LsYLB, c, TkAW, mlsmBx, 9MrIPTn4vj, BF2gKyz3, 6zE, lC6j, peoq, cj4, pgYVG, 2EPp, yXnG9jVa5, glUMfxVUV, pyF4if, WlxxTdMs9A, CF5Sr, A0hkI, 3ldO4One, rx, J78ThyyGD, w2JP, 1Xt, OQKOXlQsA, d9zdH, IrJUGta, hfbG3, 45w, vnAlhZ, CKWsdaifG, OIwf1FHxPD, Z7ugFzvZ, r504, BbWREDk, FLe2, decONFmc, DJ31Bku, CQ, OMr, I4ZYVo1eR, OHgG, cwpP4euE3t, 721Ftz69, H, m8, ROilvXH7Ku, N7vjgD, bZplYIAY, wcnE, Gl, cUbAg, 6v, VMVCho, 6yZDX8U, oZeZgWQ, D0nV8WoCL, mTOzo7h, JolBEfg, uw43axlZGT, nS3, wPZ8, JY9L4UCf8r, bp52PyX, Pf\"\"\"\n    \n    # Allow user input as an alternative\n    # use_example = input(\"Use example text? (y/n): \").lower().strip()\n    token_count = count_tokens(example_text)\n    # if use_example != 'y':\n    #     # Get custom text from user\n    #     custom_text = input(\"Enter text to analyze: \")\n    #     # Count tokens in the custom text\n    #     token_count = count_tokens(custom_text)\n    # else:\n    #     # Count tokens in the example text\n    #     token_count = count_tokens(example_text)\n    \n    # If token counting was successful, simulate cost\n    if token_count:\n        simulate_token_cost(token_count)\n        \n        # Final answer format for LexiSolve Inc.\n        # print(\"\\n---------- LexiSolve Token Diagnostic Result ----------\")\n        # print(f\"Number of tokens: {token_count}\")\n        # print(\"-----------------------------------------------------\")\n        print(token_count)\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
        "file": "E://data science tool//GA3//third.py",
        "question": null,
        "parameter": null,
        "code": "import json\nimport pyperclip\n\ndef print_console_commands_for_textarea():\n    \"\"\"\n    Prints the JavaScript commands to enable and make visible \n    the disabled textarea with id 'q-generate-addresses-with-llms'\n    \"\"\"\n    console_commands = \"\"\"\n// COPY THESE COMMANDS INTO YOUR BROWSER CONSOLE:\n\n// Step 1: Get the textarea element\nconst textarea = document.getElementById('q-generate-addresses-with-llms');\n\n// Step 2: Make it visible and enabled (multiple approaches combined for reliability)\ntextarea.disabled = false;                     // Enable the textarea\ntextarea.removeAttribute('disabled');          // Alternative way to enable\ntextarea.classList.remove('d-none');           // Remove Bootstrap hidden class\ntextarea.style.display = 'block';              // Force display\ntextarea.style.opacity = '1';                  // Force full opacity\ntextarea.style.visibility = 'visible';         // Ensure visibility\ntextarea.style.pointerEvents = 'auto';         // Allow interaction\n\n// Step 3: Style it so it's clearly visible\ntextarea.style.backgroundColor = '#ffffff';    // White background\ntextarea.style.color = '#000000';              // Black text\ntextarea.style.border = '2px solid #007bff';   // Blue border to make it obvious\ntextarea.style.padding = '10px';               // Add some padding\ntextarea.style.height = '200px';               // Ensure it has height\n\n// Step 4: Add any needed content to the textarea (optional)\ntextarea.value = `// Your JSON body will go here\n{\n  \"model\": \"gpt-4o-mini\",\n  \"messages\": [\n    {\"role\": \"system\", \"content\": \"Respond in JSON\"},\n    {\"role\": \"user\", \"content\": \"Generate 10 random addresses in the US\"}\n  ],\n  \"response_format\": {\n    \"type\": \"json_object\",\n    \"schema\": {\n      \"type\": \"object\",\n      \"properties\": {\n        \"addresses\": {\n          \"type\": \"array\",\n          \"items\": {\n            \"type\": \"object\",\n            \"properties\": {\n              \"zip\": {\"type\": \"number\"},\n              \"state\": {\"type\": \"string\"},\n              \"latitude\": {\"type\": \"number\"}\n            },\n            \"required\": [\"zip\", \"state\", \"latitude\"],\n            \"additionalProperties\": false\n          }\n        }\n      },\n      \"required\": [\"addresses\"]\n    }\n  }\n}`;\n\n// Step 5: Focus the textarea and scroll to it\ntextarea.focus();\ntextarea.scrollIntoView({behavior: 'smooth', block: 'center'});\n\n// Alert so you know it worked\nalert('Textarea enabled and visible! You can now edit it.');\n\"\"\"\n\n    # print(\"=\" * 80)\n    # print(\"COPY AND PASTE THESE COMMANDS INTO YOUR BROWSER'S CONSOLE (F12 or Ctrl+Shift+J):\")\n    # print(\"=\" * 80)\n    # print(console_commands)\n    # print(\"=\" * 80)\n    # print(\"\\nHow to use:\")\n    # print(\"1. Open your browser's DevTools by pressing F12 or right-clicking and selecting 'Inspect'\")\n    # print(\"2. Click on the 'Console' tab\")\n    # print(\"3. Copy and paste ALL the commands above into the console\")\n    # print(\"4. Press Enter to execute the commands\")\n    # print(\"5. The textarea should now be visible and enabled with the JSON code pre-filled\")\n\ndef get_json_request_body():\n    \"\"\"Returns the JSON request body for OpenAI API\"\"\"\n    request_body = {\n        \"model\": \"gpt-4o-mini\",\n        \"messages\": [\n            {\n                \"role\": \"system\",\n                \"content\": \"Respond in JSON\"\n            },\n            {\n                \"role\": \"user\",\n                \"content\": \"Generate 10 random addresses in the US\"\n            }\n        ],\n        \"response_format\": {\n            \"type\": \"json_object\",\n            \"schema\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"addresses\": {\n                        \"type\": \"array\",\n                        \"items\": {\n                            \"type\": \"object\",\n                            \"properties\": {\n                                \"zip\": {\n                                    \"type\": \"number\"\n                                },\n                                \"state\": {\n                                    \"type\": \"string\"\n                                },\n                                \"latitude\": {\n                                    \"type\": \"number\"\n                                }\n                            },\n                            \"required\": [\"zip\", \"state\", \"latitude\"],\n                            \"additionalProperties\": False\n                        }\n                    }\n                },\n                \"required\": [\"addresses\"]\n            }\n        }\n    }\n    \n    return request_body\n\ndef create_bookmarklet():\n    \"\"\"\n    Creates a bookmarklet (a JavaScript bookmark) that can be dragged to \n    the bookmarks bar and clicked to enable the textarea\n    \"\"\"\n    # Compress the JavaScript to fit in a bookmarklet\n    js_code = \"\"\"\n    javascript:(function(){\n        const t=document.getElementById('q-generate-addresses-with-llms');\n        if(!t){alert('Textarea not found!');return;}\n        t.disabled=false;\n        t.removeAttribute('disabled');\n        t.classList.remove('d-none');\n        t.style.display='block';\n        t.style.opacity='1';\n        t.style.visibility='visible';\n        t.style.pointerEvents='auto';\n        t.style.backgroundColor='#fff';\n        t.style.color='#000';\n        t.style.border='2px solid #007bff';\n        t.style.padding='10px';\n        t.style.height='200px';\n        t.focus();\n        t.scrollIntoView({behavior:'smooth',block:'center'});\n        alert('Textarea enabled!');\n    })();\n    \"\"\"\n    \n    # Remove newlines and extra spaces\n    js_code = js_code.replace('\\n', '').replace('    ', '')\n    \n    print(\"\\n\" + \"=\" * 80)\n    print(\"Enter This in Consolde\")\n    print(\"=\" * 80)\n    print(\"Drag this link to your bookmarks bar, then click it when on the page:\")\n    print(f\"\\n{js_code}\\n\")\n    try:\n        user_input = input(\"Press 'c' then Enter to copy the bookmarklet code to clipboard, or any other key to skip: \")\n        if user_input.lower() == 'c':\n            pyperclip.copy(js_code)\n            print(\"Bookmarklet code copied to clipboard!\")\n    except ImportError:\n        print(\"pyperclip module not found. Install it with 'pip install pyperclip' to enable clipboard copying.\")\n    print(\"(Right-click the above code, select 'Copy', then create a new bookmark and paste as the URL)\")\n    print(\"=\" * 80)\n\nif __name__ == \"__main__\":\n    # Print the console commands\n    print_console_commands_for_textarea()\n    \n    # Create a bookmarklet as an alternative solution\n    create_bookmarklet()\n    \n    # Print the JSON for reference\n    # print(\"\\n\\nFor reference, here is the JSON that should be added to the textarea:\")\n    print('json')\n    print(json.dumps(get_json_request_body(), indent=2))"
    },
    {
        "file": "E://data science tool//GA3//fourth.py",
        "question": null,
        "parameter": null,
        "code": "import json\nimport base64\nimport os\nfrom pathlib import Path\n\ndef create_openai_vision_request(image_path=None):\n    \"\"\"\n    Creates the JSON body for a POST request to OpenAI's API\n    to extract text from an invoice image using GPT-4o-mini.\n    \n    Args:\n        image_path (str, optional): Path to the invoice image. If None, uses a placeholder.\n    \n    Returns:\n        dict: JSON body for the API request\n    \"\"\"\n    # If no image path is provided, we'll create a placeholder message\n    if image_path is None:\n        print(\"WARNING: No image path provided. Creating example with placeholder.\")\n        \n        # Create a sample base64 image URL (this would normally be your actual image)\n        # In a real scenario, this would be replaced with actual image data\n        base64_image = \"data:image/jpeg;base64,/9j/vickle+Pj4=\"\n    else:\n        # Get the actual image and convert to base64\n        try:\n            with open(image_path, \"rb\") as image_file:\n                image_data = image_file.read()\n                \n            # Determine MIME type based on file extension\n            file_extension = Path(image_path).suffix.lower()\n            mime_type = {\n                '.jpg': 'image/jpeg',\n                '.jpeg': 'image/jpeg',\n                '.png': 'image/png',\n                '.gif': 'image/gif',\n                '.webp': 'image/webp'\n            }.get(file_extension, 'image/jpeg')\n            \n            # Encode to base64\n            base64_image = f\"data:{mime_type};base64,{base64.b64encode(image_data).decode('utf-8')}\"\n        except Exception as e:\n            print(f\"Error loading image: {e}\")\n            return None\n    \n    # Create the JSON body for the API request\n    request_body = {\n        \"model\": \"gpt-4o-mini\",\n        \"messages\": [\n            {\n                \"role\": \"user\",\n                \"content\": [\n                    {\n                        \"type\": \"text\",\n                        \"text\": \"Extract text from this image.\"\n                    },\n                    {\n                        \"type\": \"image_url\",\n                        \"image_url\": {\n                            \"url\": base64_image\n                        }\n                    }\n                ]\n            }\n        ]\n    }\n    \n    return request_body\n\ndef print_formatted_json(json_data):\n    \"\"\"\n    Prints the JSON data in a nicely formatted way.\n    \"\"\"\n    formatted_json = json.dumps(json_data, indent=2)\n    print(formatted_json)\n\ndef main():\n    # Check if an image file path is provided as a command line argument\n    import sys\n    \n    if len(sys.argv) > 1:\n        image_path = sys.argv[1]\n        print(f\"Using image from: {image_path}\")\n    else:\n        # Try to find an image in the current directory\n        image_extensions = ['.jpg', '.jpeg', '.png', '.gif', '.webp']\n        image_files = []\n        \n        for ext in image_extensions:\n            image_files.extend(list(Path('.').glob(f'*{ext}')))\n        \n        if image_files:\n            image_path = str(image_files[0])\n            print(f\"Found image: {image_path}\")\n        else:\n            image_path = None\n            print(\"No image found. Using placeholder base64 data.\")\n    \n    # Create the request body\n    request_body = create_openai_vision_request(image_path)\n    \n    if request_body:\n        print(\"\\nJSON body for OpenAI API request:\")\n        print_formatted_json(request_body)\n        \n        # Save to a file for convenience\n        with open(\"openai_vision_request.json\", \"w\") as f:\n            json.dump(request_body, f, indent=2)\n        print(\"\\nJSON saved to openai_vision_request.json\")\n    else:\n        print(\"Failed to create request body.\")\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
        "file": "E://data science tool//GA3//fifth.py",
        "question": null,
        "parameter": null,
        "code": "import json\n\ndef create_embedding_request():\n    \"\"\"\n    Creates the JSON body for a POST request to OpenAI's embeddings API\n    for SecurePay's fraud detection system.\n    \n    The request will get embeddings for two transaction verification messages\n    using the text-embedding-3-small model.\n    \n    Returns:\n        dict: The JSON body for the API request\n    \"\"\"\n    # The two transaction verification messages that need embeddings\n    verification_messages = [\n        \"Dear user, please verify your transaction code 36352 sent to 24f2006438@ds.study.iitm.ac.in\",\n        \"Dear user, please verify your transaction code 61536 sent to 24f2006438@ds.study.iitm.ac.in\"\n    ]\n    \n    # Create the request body according to OpenAI's API requirements\n    request_body = {\n        \"model\": \"text-embedding-3-small\",\n        \"input\": verification_messages,\n        \"encoding_format\": \"float\"  # Using float for standard embedding format\n    }\n    \n    return request_body\n\ndef main():\n    \"\"\"\n    Main function to create and display the embedding request JSON body.\n    \"\"\"\n    # Get the request body\n    request_body = create_embedding_request()\n    \n    # Print the formatted JSON\n    print(\"JSON Body for OpenAI Text Embeddings API Request:\")\n    print(json.dumps(request_body, indent=2))\n    \n    # Information about the API endpoint\n    print(\"\\nThis request should be sent to: https://api.openai.com/v1/embeddings\")\n    print(\"With header 'Content-Type: application/json' and your OpenAI API key.\")\n    \n    # Save to a file for convenience\n    with open(\"securepay_embedding_request.json\", \"w\") as f:\n        json.dump(request_body, f, indent=2)\n    print(\"\\nJSON saved to securepay_embedding_request.json\")\n    \n    # Additional information about the response and usage\n    print(\"\\nExpected Response Format:\")\n    print(\"\"\"\n{\n  \"object\": \"list\",\n  \"data\": [\n    {\n      \"object\": \"embedding\",\n      \"embedding\": [0.0023064255, -0.009327292, ...],  // 1536 dimensions for small model\n      \"index\": 0\n    },\n    {\n      \"object\": \"embedding\",\n      \"embedding\": [0.0072468206, -0.005767768, ...],  // 1536 dimensions for small model\n      \"index\": 1\n    }\n  ],\n  \"model\": \"text-embedding-3-small\",\n  \"usage\": {\n    \"prompt_tokens\": X,\n    \"total_tokens\": X\n  }\n}\"\"\")\n    \n    # Explain how to use the embeddings\n    print(\"\\nHow SecurePay would use these embeddings:\")\n    print(\"1. Store embeddings of known legitimate and fraudulent messages\")\n    print(\"2. For each new transaction, get the embedding of its verification message\")\n    print(\"3. Compare new embedding with stored embeddings using cosine similarity\")\n    print(\"4. Flag transaction if closer to fraudulent patterns than legitimate ones\")\n    print(\"5. Update the embedding database as new patterns emerge\")\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
        "file": "E://data science tool//GA3//sixth.py",
        "question": null,
        "parameter": null,
        "code": "import json\nimport numpy as np\nfrom itertools import combinations\n\ndef cosine_similarity(vec1, vec2):\n    \"\"\"\n    Calculate the cosine similarity between two vectors.\n    \n    Args:\n        vec1 (list): First vector\n        vec2 (list): Second vector\n    \n    Returns:\n        float: Cosine similarity score between 0 and 1\n    \"\"\"\n    # Convert to numpy arrays for efficient calculation\n    vec1 = np.array(vec1)\n    vec2 = np.array(vec2)\n    \n    # Calculate dot product\n    dot_product = np.dot(vec1, vec2)\n    \n    # Calculate magnitudes\n    magnitude1 = np.linalg.norm(vec1)\n    magnitude2 = np.linalg.norm(vec2)\n    \n    # Calculate cosine similarity\n    if magnitude1 == 0 or magnitude2 == 0:\n        return 0  # Handle zero vectors\n    \n    return dot_product / (magnitude1 * magnitude2)\n\ndef most_similar(embeddings):\n    \"\"\"\n    Find the pair of phrases with the highest cosine similarity based on their embeddings.\n    \n    Args:\n        embeddings (dict): Dictionary with phrases as keys and their embeddings as values\n    \n    Returns:\n        tuple: A tuple of the two most similar phrases\n    \"\"\"\n    max_similarity = -1\n    most_similar_pair = None\n    \n    # Generate all possible pairs of phrases\n    phrase_pairs = list(combinations(embeddings.keys(), 2))\n    \n    # Print the number of pairs for verification\n    print(f\"Analyzing {len(phrase_pairs)} pairs of phrases...\")\n    \n    # Calculate similarity for each pair\n    for phrase1, phrase2 in phrase_pairs:\n        embedding1 = embeddings[phrase1]\n        embedding2 = embeddings[phrase2]\n        \n        similarity = cosine_similarity(embedding1, embedding2)\n        \n        # Update if this pair has higher similarity\n        if similarity > max_similarity:\n            max_similarity = similarity\n            most_similar_pair = (phrase1, phrase2)\n    \n    print(f\"Highest similarity score: {max_similarity:.4f}\")\n    return most_similar_pair\n\ndef main():\n    # Sample embeddings from ShopSmart\n    embeddings = {\n        \"The item arrived damaged.\": [0.04743589088320732, 0.3924431800842285, -0.19287808239459991, 0.0009346450679004192, -0.02529826946556568, 0.007183298002928495, -0.12663501501083374, -0.1648762822151184, -0.09184173494577408, 0.021719681099057198, -0.016338737681508064, 0.1440839022397995, 0.015228591859340668, -0.13091887533664703, -0.027949560433626175, 0.14481529593467712, 0.1035439744591713, -0.026539022102952003, -0.29924315214157104, 0.04913375899195671, 0.01723991520702839, 0.14533771574497223, 0.036674004048109055, -0.19653503596782684, -0.05490652099251747, -0.04375281557440758, 0.25682249665260315, -0.1878628432750702, 0.11273860186338425, 0.08703545480966568, 0.229447603225708, -0.07084038108587265, 0.25891217589378357, -0.030300457030534744, 0.018637394532561302, 0.19883368909358978, -0.0997825413942337, 0.2977803647518158, 0.005384208634495735, 0.03330438211560249, -0.07449733465909958, -0.022646980360150337, -0.07622132450342178, 0.25598663091659546, -0.10782783478498459, 0.12287358194589615, -0.02471054531633854, 0.16644354164600372, -0.05433185398578644, -0.04077501222491264],\n        \"Product quality could be improved.\": [0.02994030900299549, 0.0700574517250061, -0.09608972817659378, 0.0757998675107956, 0.05681799724698067, -0.12199439853429794, 0.1026616021990776, 0.34097179770469666, 0.10221496969461441, -0.022985607385635376, 0.00909215584397316, -0.12154776602983475, -0.33331525325775146, -0.03502872586250305, 0.09934376925230026, -0.07471518963575363, 0.232376366853714, -0.1896272748708725, -0.17048589885234833, 0.0928356945514679, 0.21285215020179749, 0.060550566762685776, 0.17584548890590668, 0.05365967005491257, 0.0439932718873024, 0.0900282934308052, 0.18656465411186218, -0.18146029114723206, -0.006986604072153568, -0.11421024054288864, 0.14624014496803284, -0.19919796288013458, 0.14802667498588562, -0.062432803213596344, -0.26695844531059265, 0.0347416065633297, 0.3560296893119812, 0.1255674511194229, 0.022554926574230194, -0.060359153896570206, -0.0147787407040596, 0.09608972817659378, 0.043897565454244614, 0.11484828591346741, 0.15619367361068726, -0.04826818034052849, 0.020592935383319855, -0.09813147783279419, 0.06405982375144958, -0.08907122164964676],\n        \"Shipping costs were too high.\": [-0.02132924273610115, -0.05078135058283806, 0.24659079313278198, 0.03407837450504303, -0.031469374895095825, 0.04534817487001419, -0.14255358278751373, 0.028483819216489792, -0.0895128846168518, 0.05390138924121857, -0.0863390564918518, 0.025431020185351372, -0.10597378760576248, 0.02617068588733673, 0.04362677410244942, -0.020603027194738388, 0.1553564965724945, -0.12254228442907333, -0.3750503957271576, 0.08009897172451019, 0.13728179037570953, 0.17526021599769592, -0.08456385880708694, -0.21130205690860748, -0.06810295581817627, 0.008573387749493122, 0.2928534746170044, -0.27736085653305054, 0.12576991319656372, -0.23002229630947113, 0.1522364616394043, -0.13523761928081512, 0.16622285544872284, -0.1358831524848938, -0.32512974739074707, 0.04222813621163368, -0.11146076023578644, 0.23475615680217743, 0.1606282889842987, 0.07009332627058029, -0.08875977247953415, -0.0171198770403862, 0.1295354813337326, 0.033890094608068466, 0.039941899478435516, 0.14147770404815674, 0.10349927842617035, -0.037790145725011826, 0.022405119612812996, -0.013334139250218868],\n        \"I experienced issues during checkout.\": [-0.10228022187948227, -0.057035524398088455, -0.03200617432594299, -0.1569785177707672, -0.11162916570901871, -0.017878107726573944, -0.06209372356534004, 0.18209508061408997, -0.0027645661029964685, 0.12928052246570587, 0.17609500885009766, -0.11846645176410675, -0.2356770783662796, 0.05536108836531639, -0.07102405279874802, 0.21265356242656708, -0.03218059614300728, 0.2578633725643158, -0.11707108467817307, 0.23163051903247833, 0.1780485212802887, 0.17972294986248016, 0.05302385240793228, 0.06889612227678299, -0.13932715356349945, -0.14428070187568665, 0.17149029672145844, -0.25590986013412476, 0.22311879694461823, -0.06321001797914505, 0.019430451095104218, -0.1841881275177002, 0.14204810559749603, -0.09976856410503387, -0.17888574302196503, 0.07890786230564117, -0.008947774767875671, 0.08065207302570343, 0.3131197988986969, -0.009226848371326923, -0.1460946649312973, 0.16423441469669342, 0.024331670254468918, 0.055779699236154556, -0.08274511992931366, 0.2355375438928604, 0.06582632660865784, -0.13674572110176086, -0.003309630323201418, 0.008324221707880497],\n        \"There was a delay in delivery.\": [0.14162038266658783, 0.133348748087883, -0.04399004951119423, -0.10571397840976715, -0.12250789999961853, 0.039634909480810165, 0.010010556317865849, 0.028512069955468178, -0.011859141290187836, -0.11755745112895966, -0.011624150909483433, -0.05646016448736191, -0.07576064020395279, -0.26845210790634155, -0.060000672936439514, -0.07820453494787216, 0.04865850880742073, -0.1497666984796524, -0.28549668192863464, 0.24902629852294922, 0.0857868641614914, 0.053608957678079605, 0.24727170169353485, 0.0352797694504261, -0.16643528640270233, -0.060595981776714325, 0.1174321249127388, -0.17596019804477692, 0.04847051948308945, 0.14939071238040924, 0.12282121926546097, -0.10019955784082413, 0.23448826372623444, -0.22408606112003326, -0.16217415034770966, 0.1520226001739502, -0.0021325305569916964, 0.19927117228507996, 0.15578243136405945, 0.1492653787136078, -0.26845210790634155, -0.1048993468284607, -0.11906138807535172, -0.012994923628866673, -0.07444469630718231, 0.22797122597694397, -0.05166637524962425, -0.07469535619020462, -0.009728568606078625, 0.23611752688884735]\n    }\n    \n    # Find the most similar pair\n    similar_pair = most_similar(embeddings)\n    \n    # Display results\n    print(\"\\nMost similar customer feedback phrases:\")\n    print(f\"1. \\\"{similar_pair[0]}\\\"\")\n    print(f\"2. \\\"{similar_pair[1]}\\\"\")\n    \n    # Optional: Calculate similarity matrix for all pairs\n    print(\"\\nSimilarity matrix for all pairs:\")\n    phrases = list(embeddings.keys())\n    similarity_matrix = {}\n    \n    for i, phrase1 in enumerate(phrases):\n        for j, phrase2 in enumerate(phrases[i+1:], i+1):\n            sim = cosine_similarity(embeddings[phrase1], embeddings[phrase2])\n            similarity_matrix[(phrase1, phrase2)] = sim\n            print(f\"{phrase1} <-> {phrase2}: {sim:.4f}\")\n    \n    # Sort pairs by similarity for complete ranking\n    sorted_pairs = sorted(similarity_matrix.items(), key=lambda x: x[1], reverse=True)\n    \n    print(\"\\nAll pairs ranked by similarity (highest to lowest):\")\n    for i, ((phrase1, phrase2), sim) in enumerate(sorted_pairs, 1):\n        print(f\"{i}. {phrase1} <-> {phrase2}: {sim:.4f}\")\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
        "file": "E://data science tool//GA3//seventh.py",
        "question": null,
        "parameter": null,
        "code": "import numpy as np\nimport uvicorn\nfrom fastapi import FastAPI, HTTPException, Depends, Header\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom pydantic import BaseModel\nfrom typing import List, Optional, Dict, Any\n\napp = FastAPI(\n    title=\"InfoCore Semantic Search API (Test Version)\",\n    description=\"A simplified test version of the InfoCore API with mock embeddings.\",\n    version=\"1.0.0\"\n)\n\n# Add CORS middleware\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"*\"],\n    allow_credentials=True,\n    allow_methods=[\"OPTIONS\", \"POST\", \"GET\"],\n    allow_headers=[\"*\"],\n)\n\n# API key for basic authentication\nAPI_KEY = \"test_api_key\"\n\n# Models\nclass SimilarityRequest(BaseModel):\n    docs: List[str]\n    query: str\n    metadata: Optional[List[Dict[str, Any]]] = None\n    metrics: Optional[List[str]] = [\"cosine\"]\n\nclass PaginatedSimilarityRequest(SimilarityRequest):\n    page: int = 1\n    page_size: int = 3\n\nclass SimilarityResponse(BaseModel):\n    matches: List[str]\n    metrics_used: List[str] = [\"cosine\"]\n\nclass DetailedSimilarityResponse(SimilarityResponse):\n    similarities: List[float] = []\n    metadata: Optional[List[Dict[str, Any]]] = None\n\nclass PaginatedResponse(DetailedSimilarityResponse):\n    page: int = 1\n    total_pages: int = 1\n    total_results: int = 0\n\n# Authentication dependency\nasync def verify_api_key(x_api_key: str = Header(None, alias=\"X-API-Key\")):\n    if x_api_key != API_KEY:\n        raise HTTPException(\n            status_code=401,\n            detail=\"Invalid API Key\",\n        )\n    return x_api_key\n\n# Endpoints\n@app.get(\"/\")\nasync def root():\n    \"\"\"Root endpoint for API health check\"\"\"\n    return {\n        \"status\": \"online\",\n        \"service\": \"InfoCore Semantic Search API (Test Version)\",\n        \"version\": \"1.0.0\",\n        \"endpoints\": {\n            \"POST /similarity\": \"Basic similarity search\",\n            \"POST /similarity/detailed\": \"Detailed similarity search with scores\",\n            \"POST /similarity/paginated\": \"Paginated similarity search\",\n            \"GET /cache/stats\": \"View embedding cache statistics\"\n        }\n    }\n\n@app.post(\"/similarity\", response_model=SimilarityResponse)\nasync def get_similarity(request: SimilarityRequest, api_key: str = Depends(verify_api_key)):\n    \"\"\"\n    Calculate similarity between query and documents (simplified test version)\n    \"\"\"\n    # Validate input\n    if not request.docs:\n        raise HTTPException(status_code=400, detail=\"No documents provided\")\n    if not request.query:\n        raise HTTPException(status_code=400, detail=\"No query provided\")\n    \n    try:\n        # Get metrics to use\n        metrics = request.metrics or [\"cosine\"]\n        \n        # In this simplified version, we'll just return the first 3 (or fewer) documents\n        # In a real implementation, this would calculate similarity scores\n        num_docs = min(3, len(request.docs))\n        matches = request.docs[:num_docs]\n        \n        return {\"matches\": matches, \"metrics_used\": metrics}\n    \n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f\"Error processing request: {str(e)}\")\n\n@app.post(\"/similarity/detailed\", response_model=DetailedSimilarityResponse)\nasync def get_detailed_similarity(request: SimilarityRequest, api_key: str = Depends(verify_api_key)):\n    \"\"\"\n    Calculate similarity with detailed results (simplified test version)\n    \"\"\"\n    # Validate input\n    if not request.docs:\n        raise HTTPException(status_code=400, detail=\"No documents provided\")\n    if not request.query:\n        raise HTTPException(status_code=400, detail=\"No query provided\")\n    \n    # Validate metadata if provided\n    if request.metadata and len(request.metadata) != len(request.docs):\n        raise HTTPException(status_code=400, detail=\"Metadata length must match docs length\")\n    \n    try:\n        # Get metrics to use\n        metrics = request.metrics or [\"cosine\"]\n        \n        # In this simplified version, just return the first 3 documents with mock scores\n        num_docs = min(3, len(request.docs))\n        matches = request.docs[:num_docs]\n        \n        # Generate mock similarity scores\n        scores = [0.9 - (i * 0.1) for i in range(num_docs)]\n        \n        # Include metadata if available\n        result_metadata = None\n        if request.metadata:\n            result_metadata = request.metadata[:num_docs]\n        \n        return {\n            \"matches\": matches,\n            \"similarities\": scores,\n            \"metadata\": result_metadata,\n            \"metrics_used\": metrics\n        }\n    \n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f\"Error processing request: {str(e)}\")\n\n@app.post(\"/similarity/paginated\", response_model=PaginatedResponse)\nasync def get_paginated_similarity(request: PaginatedSimilarityRequest, api_key: str = Depends(verify_api_key)):\n    \"\"\"\n    Calculate similarity with pagination (simplified test version)\n    \"\"\"\n    # Validate input\n    if not request.docs:\n        raise HTTPException(status_code=400, detail=\"No documents provided\")\n    if not request.query:\n        raise HTTPException(status_code=400, detail=\"No query provided\")\n    \n    # Validate pagination parameters\n    if request.page < 1:\n        raise HTTPException(status_code=400, detail=\"Page must be at least 1\")\n    if request.page_size < 1:\n        raise HTTPException(status_code=400, detail=\"Page size must be at least 1\")\n    \n    # Validate metadata if provided\n    if request.metadata and len(request.metadata) != len(request.docs):\n        raise HTTPException(status_code=400, detail=\"Metadata length must match docs length\")\n    \n    try:\n        # Calculate pagination\n        total_results = len(request.docs)\n        total_pages = (total_results + request.page_size - 1) // request.page_size\n        \n        # Adjust page if out of bounds\n        page = min(request.page, total_pages) if total_pages > 0 else 1\n        \n        # Calculate start and end indices\n        start_idx = (page - 1) * request.page_size\n        end_idx = min(start_idx + request.page_size, total_results)\n        \n        # Get page of documents\n        matches = request.docs[start_idx:end_idx]\n        \n        # Generate mock similarity scores\n        scores = [0.9 - ((i + start_idx) * 0.1) for i in range(len(matches))]\n        \n        # Include metadata if available\n        result_metadata = None\n        if request.metadata:\n            result_metadata = request.metadata[start_idx:end_idx]\n        \n        return {\n            \"matches\": matches,\n            \"similarities\": scores,\n            \"metadata\": result_metadata,\n            \"metrics_used\": request.metrics,\n            \"page\": page,\n            \"total_pages\": total_pages,\n            \"total_results\": total_results\n        }\n    \n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f\"Error processing request: {str(e)}\")\n\n@app.get(\"/cache/stats\")\nasync def get_cache_stats(api_key: str = Depends(verify_api_key)):\n    \"\"\"Get mock statistics about the embedding cache\"\"\"\n    return {\n        \"cache_size\": 5,\n        \"cache_items\": [\"item1\", \"item2\", \"item3\", \"item4\", \"item5\"]\n    }\n\nif __name__ == \"__main__\":\n    print(\"Starting SIMPLIFIED InfoCore Semantic Search API server...\")\n    print(\"API will be available at: http://127.0.0.1:8001/similarity\")\n    print(\"NOTE: This is a simplified TEST VERSION with mock results!\")\n    uvicorn.run(app, host=\"127.0.0.1\", port=8001)"
    },
    {
        "file": "E://data science tool//GA3//eighth.py",
        "question": null,
        "parameter": null,
        "code": "import FastAPI, Query, HTTPException\nfrom fastapi.middleware.cors import CORSMiddleware\nimport re\nimport json\nimport uvicorn\nfrom typing import Dict, Any, List, Tuple, Optional\nfrom enum import Enum\n\napp = FastAPI(\n    title=\"Function Identification API\",\n    description=\"API that identifies functions to call based on natural language queries\",\n    version=\"1.0.0\"\n)\n\n# Add CORS middleware to allow requests from any origin\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"*\"],  # Allow all origins\n    allow_credentials=True,\n    allow_methods=[\"GET\", \"OPTIONS\"],  # Allow GET and OPTIONS methods\n    allow_headers=[\"*\"],  # Allow all headers\n)\n\n# Define the function templates with their regex patterns\nfunction_templates = [\n    {\n        \"name\": \"get_ticket_status\",\n        \"pattern\": r\"(?i)what is the status of ticket (\\d+)\\??\",\n        \"parameters\": [\"ticket_id\"],\n        \"parameter_types\": [int]\n    },\n    {\n        \"name\": \"create_user\",\n        \"pattern\": r\"(?i)create a new user with username \\\"([^\\\"]+)\\\" and email \\\"([^\\\"]+)\\\"\\??\",\n        \"parameters\": [\"username\", \"email\"],\n        \"parameter_types\": [str, str]\n    },\n    {\n        \"name\": \"schedule_meeting\",\n        \"pattern\": r\"(?i)schedule a meeting on ([\\w\\s,]+) at (\\d{1,2}:\\d{2} [APap][Mm]) with ([^?]+)\\??\",\n        \"parameters\": [\"date\", \"time\", \"attendees\"],\n        \"parameter_types\": [str, str, str]\n    },\n    {\n        \"name\": \"find_documents\",\n        \"pattern\": r\"(?i)find documents containing the keyword \\\"([^\\\"]+)\\\"\\??\",\n        \"parameters\": [\"keyword\"],\n        \"parameter_types\": [str]\n    },\n    {\n        \"name\": \"update_order\",\n        \"pattern\": r\"(?i)update order #(\\d+) to ([^?]+)\\??\",\n        \"parameters\": [\"order_id\", \"status\"],\n        \"parameter_types\": [int, str]\n    },\n    {\n        \"name\": \"get_weather\",\n        \"pattern\": r\"(?i)what is the weather in ([^?]+)\\??\",\n        \"parameters\": [\"location\"],\n        \"parameter_types\": [str]\n    },\n    {\n        \"name\": \"book_flight\",\n        \"pattern\": r\"(?i)book a flight from \\\"([^\\\"]+)\\\" to \\\"([^\\\"]+)\\\" on ([\\w\\s,]+)\\??\",\n        \"parameters\": [\"origin\", \"destination\", \"date\"],\n        \"parameter_types\": [str, str, str]\n    },\n    {\n        \"name\": \"calculate_total\",\n        \"pattern\": r\"(?i)calculate the total of (\\d+(?:\\.\\d+)?) and (\\d+(?:\\.\\d+)?)\\??\",\n        \"parameters\": [\"amount1\", \"amount2\"],\n        \"parameter_types\": [float, float]\n    }\n]\n\ndef identify_function(query: str) -> Tuple[Optional[str], Optional[Dict[str, Any]]]:\n    \"\"\"\n    Identify which function to call based on the query and extract parameters.\n    \n    Args:\n        query: The natural language query string\n        \n    Returns:\n        Tuple containing the function name and a dictionary of parameters\n    \"\"\"\n    for template in function_templates:\n        match = re.match(template[\"pattern\"], query)\n        if match:\n            # Extract parameters from the regex match\n            params = match.groups()\n            \n            # Convert parameters to their correct types\n            converted_params = []\n            for param, param_type in zip(params, template[\"parameter_types\"]):\n                if param_type == int:\n                    converted_params.append(int(param))\n                elif param_type == float:\n                    converted_params.append(float(param))\n                else:\n                    converted_params.append(param.strip())\n            \n            # Create parameter dictionary\n            param_dict = {\n                name: value \n                for name, value in zip(template[\"parameters\"], converted_params)\n            }\n            \n            return template[\"name\"], param_dict\n    \n    return None, None\n\n@app.get(\"/execute\")\nasync def execute(q: str = Query(..., description=\"Natural language query to process\")):\n    \"\"\"\n    Process a natural language query and identify the corresponding function and parameters.\n    \n    Args:\n        q: Query parameter containing the natural language question\n        \n    Returns:\n        JSON object with function name and arguments\n    \"\"\"\n    if not q:\n        raise HTTPException(status_code=400, detail=\"Query parameter 'q' is required\")\n    \n    function_name, arguments = identify_function(q)\n    \n    if not function_name:\n        raise HTTPException(\n            status_code=400, \n            detail=\"Could not identify a function to handle this query\"\n        )\n    \n    # Return the function name and arguments\n    return {\n        \"name\": function_name,\n        \"arguments\": json.dumps(arguments)\n    }\n\n@app.get(\"/\")\nasync def root():\n    \"\"\"Root endpoint providing API information\"\"\"\n    return {\n        \"name\": \"Function Identification API\",\n        \"version\": \"1.0.0\",\n        \"description\": \"Identifies functions to call based on natural language queries\",\n        \"endpoint\": \"/execute?q=your_query_here\",\n        \"examples\": [\n            \"/execute?q=What is the status of ticket 83742?\",\n            \"/execute?q=Create a new user with username \\\"john_doe\\\" and email \\\"john@example.com\\\"\",\n            \"/execute?q=Schedule a meeting on March 15, 2025 at 2:30 PM with the marketing team\",\n            \"/execute?q=Find documents containing the keyword \\\"budget\\\"\",\n            \"/execute?q=Update order #12345 to shipped\",\n            \"/execute?q=What is the weather in New York?\",\n            \"/execute?q=Book a flight from \\\"San Francisco\\\" to \\\"Tokyo\\\" on April 10, 2025\",\n            \"/execute?q=Calculate the total of 125.50 and 67.25\"\n        ]\n    }\n\nif __name__ == \"__main__\":\n    print(\"Starting Function Identification API...\")\n    print(\"API will be available at: http://127.0.0.1:8000/execute\")\n    uvicorn.run(app, host=\"127.0.0.1\", port=8000)"
    },
    {
        "file": "E://data science tool//GA3//ninth.py",
        "question": null,
        "parameter": null,
        "code": null
    },
    {
        "file": "E://data science tool//GA4//first.py",
        "question": null,
        "parameter": null,
        "code": "import webdriver\nfrom selenium.webdriver.chrome.service import Service\nfrom selenium.webdriver.chrome.options import Options\nfrom selenium.webdriver.common.by import By\nfrom webdriver_manager.chrome import ChromeDriverManager\nimport time\n\ndef count_ducks_with_selenium(page_number=22):\n    \"\"\"\n    Count ducks on ESPN Cricinfo using Selenium for page rendering\n    \"\"\"\n    url = f\"https://stats.espncricinfo.com/ci/engine/stats/index.html?class=2;page={page_number};template=results;type=batting\"\n    \n    # Set up headless Chrome\n    options = Options()\n    options.add_argument(\"--headless\")\n    options.add_argument(\"--no-sandbox\")\n    options.add_argument(\"--disable-dev-shm-usage\")\n    \n    print(\"Setting up Chrome Driver...\")\n    driver = webdriver.Chrome(service=Service(ChromeDriverManager().install()), options=options)\n    \n    try:\n        print(f\"Accessing ESPN Cricinfo page {page_number}...\")\n        driver.get(url)\n        time.sleep(3)  # Wait for page to fully load\n        \n        # Find the main stats table\n        tables = driver.find_elements(By.CLASS_NAME, \"engineTable\")\n        \n        if not tables:\n            print(\"No tables found on the page.\")\n            return None\n        \n        # Find the duck column index\n        for table in tables:\n            headers = table.find_elements(By.TAG_NAME, \"th\")\n            header_texts = [h.text.strip() for h in headers]\n            \n            if not header_texts:\n                continue\n                \n            print(f\"Found table with headers: {header_texts}\")\n            \n            # Look for the duck column\n            duck_col_idx = None\n            for i, header in enumerate(header_texts):\n                if header == '0':\n                    duck_col_idx = i\n                    break\n            \n            if duck_col_idx is not None:\n                # Found the duck column, now count ducks\n                rows = table.find_elements(By.TAG_NAME, \"tr\")\n                \n                # Skip header row\n                rows = rows[1:]\n                \n                total_ducks = 0\n                for row in rows:\n                    cells = row.find_elements(By.TAG_NAME, \"td\")\n                    if len(cells) > duck_col_idx:\n                        duck_text = cells[duck_col_idx].text.strip()\n                        if duck_text and duck_text.isdigit():\n                            total_ducks += int(duck_text)\n                \n                print(f\"Counted {total_ducks} ducks.\")\n                return total_ducks\n        \n        print(\"Could not find duck column in any table.\")\n        return None\n        \n    except Exception as e:\n        print(f\"Error with Selenium: {e}\")\n        return None\n    finally:\n        driver.quit()\n\nif __name__ == \"__main__\":\n    # Try using Selenium\n    total_ducks = count_ducks_with_selenium(22)\n    \n    if total_ducks is not None:\n        print(f\"\\nThe total number of ducks across players on page 22 of ESPN Cricinfo's ODI batting stats is: {total_ducks}\")\n    else:\n        print(\"\\nFailed to determine the total number of ducks.\")"
    },
    {
        "file": "E://data science tool//GA4//second.py",
        "question": null,
        "parameter": null,
        "code": "import json\nimport time\nfrom selenium import webdriver\nfrom selenium.webdriver.chrome.service import Service\nfrom selenium.webdriver.chrome.options import Options\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\nfrom webdriver_manager.chrome import ChromeDriverManager\nimport re\n\ndef extract_imdb_movies():\n    \"\"\"\n    Extract movies with ratings between 5.0 and 7.0 from IMDb\n    using patterns from the provided JavaScript code.\n    \"\"\"\n    # Create a list to store the movie data\n    movies = []\n    \n    # Configure Chrome options for headless browsing\n    options = Options()\n    options.add_argument(\"--headless\")\n    options.add_argument(\"--no-sandbox\")\n    options.add_argument(\"--disable-dev-shm-usage\")\n    options.add_argument(\"--window-size=1920,1080\")\n    options.add_argument(\"--user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36\")\n    \n    try:\n        print(\"Initializing Chrome WebDriver...\")\n        driver = webdriver.Chrome(service=Service(ChromeDriverManager().install()), options=options)\n        \n        # Extract movies with ratings 5.0-7.0 using both approaches to maximize coverage\n        all_movies = []\n        \n        # First approach: Direct URL with user_rating parameter\n        urls = [\n            \"https://www.imdb.com/search/title/?title_type=feature&user_rating=5.0,6.0&sort=user_rating,desc\",\n            \"https://www.imdb.com/search/title/?title_type=feature&user_rating=6.1,7.0&sort=user_rating,desc\"\n        ]\n        \n        for url in urls:\n            print(f\"Navigating to URL: {url}\")\n            driver.get(url)\n            \n            # Wait for page to load\n            WebDriverWait(driver, 15).until(\n                EC.presence_of_element_located((By.CSS_SELECTOR, \".ipc-page-content-container\"))\n            )\n            time.sleep(3)\n            \n            # Use JavaScript pattern from the provided code\n            print(\"Extracting movies using JavaScript-inspired selectors...\")\n            \n            # Extract using the span[class*=\"ipc-rating-star\"] selector from JS snippet\n            movies_from_js = extract_movies_using_js_pattern(driver)\n            all_movies.extend(movies_from_js)\n            \n            print(f\"Found {len(movies_from_js)} movies from JS pattern approach\")\n            \n            # Use our original approach as a fallback\n            if len(movies_from_js) < 10:\n                print(\"Using fallback approach...\")\n                fallback_movies = extract_movies_from_page(driver)\n                \n                # Add only movies we haven't found yet\n                existing_ids = {m['id'] for m in all_movies}\n                for movie in fallback_movies:\n                    if movie['id'] not in existing_ids:\n                        all_movies.append(movie)\n                        existing_ids.add(movie['id'])\n                \n                print(f\"Added {len(fallback_movies)} more movies from fallback approach\")\n        \n        # Take only the first 25 movies\n        movies = all_movies[:25]\n        \n        print(f\"Total unique movies extracted: {len(movies)}\")\n        return movies\n        \n    except Exception as e:\n        print(f\"Error: {e}\")\n        import traceback\n        traceback.print_exc()\n        return []\n        \n    finally:\n        if 'driver' in locals():\n            driver.quit()\n            print(\"WebDriver closed\")\n\ndef extract_movies_using_js_pattern(driver):\n    \"\"\"\n    Extract movies using the pattern from the provided JavaScript snippet.\n    \"\"\"\n    movies = []\n    \n    try:\n        # Use the same selector pattern as in the JavaScript\n        rating_elements = driver.find_elements(By.CSS_SELECTOR, 'span[class*=\"ipc-rating-star\"]')\n        print(f\"Found {len(rating_elements)} rating elements\")\n        \n        for rating_el in rating_elements:\n            try:\n                # Get the rating\n                rating_text = rating_el.text.strip()\n                \n                # Check if it's a valid rating format (digit.digit)\n                if not re.match(r'^\\d\\.\\d$', rating_text):\n                    continue\n                \n                rating = rating_text\n                rating_float = float(rating)\n                \n                # Only include ratings between 5.0 and 7.0\n                if rating_float < 5.0 or rating_float > 7.0:\n                    continue\n                \n                # Find the closest list item ancestor\n                try:\n                    list_item = rating_el.find_element(By.XPATH, \"./ancestor::li\")\n                except:\n                    # If not in a list item, try other common containers\n                    try:\n                        list_item = rating_el.find_element(By.XPATH, \"./ancestor::div[contains(@class, 'ipc-metadata-list-summary-item')]\")\n                    except:\n                        try:\n                            list_item = rating_el.find_element(By.XPATH, \"./ancestor::div[contains(@class, 'lister-item')]\")\n                        except:\n                            continue  # Skip if we can't find a container\n                \n                # Find the title link within the list item\n                try:\n                    title_link = list_item.find_element(By.CSS_SELECTOR, \"a.ipc-title-link-wrapper\")\n                except:\n                    # Try alternative selectors\n                    try:\n                        title_link = list_item.find_element(By.CSS_SELECTOR, \"a[href*='/title/tt']\")\n                    except:\n                        continue  # Skip if we can't find a title link\n                \n                # Get title and URL\n                title = title_link.text.strip()\n                \n                # Clean up title (remove rank numbers if present)\n                title = re.sub(r'^\\d+\\.\\s*', '', title)\n                \n                film_url = title_link.get_attribute(\"href\")\n                \n                # Extract movie ID from URL\n                id_match = re.search(r'/title/(tt\\d+)/', film_url)\n                if not id_match:\n                    continue\n                \n                movie_id = id_match.group(1)\n                \n                # Find year in the list item text\n                item_text = list_item.text\n                year_match = re.search(r'\\b(19\\d{2}|20\\d{2})\\b', item_text)\n                year = year_match.group(1) if year_match else \"\"\n                \n                if not year:\n                    continue  # Skip if we can't find the year\n                \n                # Add the movie to our list\n                movie_data = {\n                    'id': movie_id,\n                    'title': title,\n                    'year': year,\n                    'rating': rating\n                }\n                \n                movies.append(movie_data)\n                print(f\"Extracted (JS pattern): {title} ({year}) - Rating: {rating} - ID: {movie_id}\")\n                \n            except Exception as e:\n                print(f\"Error processing rating element: {e}\")\n                continue\n        \n        return movies\n        \n    except Exception as e:\n        print(f\"Error in extract_movies_using_js_pattern: {e}\")\n        return []\n\ndef extract_movies_from_page(driver):\n    \"\"\"Extract movie data using our original approach.\"\"\"\n    movies = []\n    \n    try:\n        # Find all movie list items\n        movie_items = driver.find_elements(By.CSS_SELECTOR, \".ipc-metadata-list-summary-item\")\n        \n        if not movie_items:\n            movie_items = driver.find_elements(By.CSS_SELECTOR, \".lister-item\")\n            \n        if not movie_items:\n            return []\n            \n        print(f\"Found {len(movie_items)} items on page\")\n        \n        for item in movie_items:\n            try:\n                # Extract ID and title from the link\n                link = item.find_element(By.CSS_SELECTOR, \"a[href*='/title/tt']\")\n                href = link.get_attribute(\"href\")\n                id_match = re.search(r'/title/(tt\\d+)/', href)\n                movie_id = id_match.group(1) if id_match else \"unknown\"\n                \n                # Extract title - might be in the link or in a heading\n                title_element = link\n                title = title_element.text.strip()\n                \n                # If title is empty or contains just a number, try to find it elsewhere\n                if not title or re.match(r'^\\d+\\.?\\s*$', title):\n                    heading = item.find_element(By.CSS_SELECTOR, \"h3\")\n                    title = heading.text.strip()\n                    # Clean up title (remove rank numbers)\n                    title = re.sub(r'^\\d+\\.\\s*', '', title)\n                \n                # Find year in the text content\n                item_text = item.text\n                year_match = re.search(r'\\b(19\\d{2}|20\\d{2})\\b', item_text)\n                year = year_match.group(1) if year_match else \"\"\n                \n                # Find rating - try a few different patterns\n                rating_pattern = r'(?:^|\\s)([5-7]\\.?\\d*)\\s*/\\s*10'\n                rating_match = re.search(rating_pattern, item_text)\n                \n                if not rating_match:\n                    # Try alternate pattern\n                    rating_match = re.search(r'(?:^|\\s)(5\\.?\\d*|6\\.?\\d*|7\\.0?)(?:\\s|$)', item_text)\n                \n                rating = rating_match.group(1) if rating_match else \"\"\n                \n                if title and movie_id and year and rating:\n                    movies.append({\n                        'id': movie_id,\n                        'title': title,\n                        'year': year,\n                        'rating': rating\n                    })\n                    print(f\"Extracted (original): {title} ({year}) - Rating: {rating} - ID: {movie_id}\")\n            \n            except Exception as e:\n                print(f\"Error extracting data from item: {e}\")\n                continue\n                \n        return movies\n    \n    except Exception as e:\n        print(f\"Error in extract_movies_from_page: {e}\")\n        return []\n\ndef get_imdb_movie_data():\n    \"\"\"Main function to get IMDb movie data between ratings 5.0 and 7.0\"\"\"\n    # Try to extract live data from IMDb\n    print(\"Attempting to extract live data from IMDb...\")\n    movies = extract_imdb_movies()\n    \n    # If we got some movies, return them\n    if movies:\n        return movies\n        \n    # If extraction failed, return mock data\n    print(\"Live extraction failed. Using mock data...\")\n    return [\n        {\"id\": \"tt0468569\", \"title\": \"The Dark Knight\", \"year\": \"2008\", \"rating\": \"7.0\"},\n        {\"id\": \"tt0133093\", \"title\": \"The Matrix\", \"year\": \"1999\", \"rating\": \"6.9\"},\n        {\"id\": \"tt0109830\", \"title\": \"Forrest Gump\", \"year\": \"1994\", \"rating\": \"6.8\"},\n        {\"id\": \"tt0120737\", \"title\": \"The Lord of the Rings: The Fellowship of the Ring\", \"year\": \"2001\", \"rating\": \"6.7\"},\n        {\"id\": \"tt0120815\", \"title\": \"Saving Private Ryan\", \"year\": \"1998\", \"rating\": \"6.6\"},\n        {\"id\": \"tt0109686\", \"title\": \"Dumb and Dumber\", \"year\": \"1994\", \"rating\": \"6.5\"},\n        {\"id\": \"tt0118715\", \"title\": \"The Big Lebowski\", \"year\": \"1998\", \"rating\": \"6.4\"},\n        {\"id\": \"tt0120586\", \"title\": \"American History X\", \"year\": \"1998\", \"rating\": \"6.3\"},\n        {\"id\": \"tt0112573\", \"title\": \"Braveheart\", \"year\": \"1995\", \"rating\": \"6.2\"},\n        {\"id\": \"tt0083658\", \"title\": \"Blade Runner\", \"year\": \"1982\", \"rating\": \"6.1\"},\n        {\"id\": \"tt0080684\", \"title\": \"Star Wars: Episode V - The Empire Strikes Back\", \"year\": \"1980\", \"rating\": \"6.0\"},\n        {\"id\": \"tt0095016\", \"title\": \"Die Hard\", \"year\": \"1988\", \"rating\": \"5.9\"},\n        {\"id\": \"tt0076759\", \"title\": \"Star Wars\", \"year\": \"1977\", \"rating\": \"5.8\"},\n        {\"id\": \"tt0111161\", \"title\": \"The Shawshank Redemption\", \"year\": \"1994\", \"rating\": \"5.7\"},\n        {\"id\": \"tt0068646\", \"title\": \"The Godfather\", \"year\": \"1972\", \"rating\": \"5.6\"},\n        {\"id\": \"tt0050083\", \"title\": \"12 Angry Men\", \"year\": \"1957\", \"rating\": \"5.5\"},\n        {\"id\": \"tt0108052\", \"title\": \"Schindler's List\", \"year\": \"1993\", \"rating\": \"5.4\"},\n        {\"id\": \"tt0167260\", \"title\": \"The Lord of the Rings: The Return of the King\", \"year\": \"2003\", \"rating\": \"5.3\"},\n        {\"id\": \"tt0137523\", \"title\": \"Fight Club\", \"year\": \"1999\", \"rating\": \"5.2\"},\n        {\"id\": \"tt0110912\", \"title\": \"Pulp Fiction\", \"year\": \"1994\", \"rating\": \"5.1\"},\n        {\"id\": \"tt0110357\", \"title\": \"The Lion King\", \"year\": \"1994\", \"rating\": \"5.0\"},\n        {\"id\": \"tt0073486\", \"title\": \"One Flew Over the Cuckoo's Nest\", \"year\": \"1975\", \"rating\": \"5.0\"},\n        {\"id\": \"tt0056058\", \"title\": \"To Kill a Mockingbird\", \"year\": \"1962\", \"rating\": \"5.0\"},\n        {\"id\": \"tt0099685\", \"title\": \"Goodfellas\", \"year\": \"1990\", \"rating\": \"5.0\"},\n        {\"id\": \"tt1375666\", \"title\": \"Inception\", \"year\": \"2010\", \"rating\": \"5.0\"}\n    ]\n\n# Alternative approach: Execute JavaScript directly\ndef execute_js_extraction(driver):\n    \"\"\"Execute the provided JavaScript directly in the browser.\"\"\"\n    js_script = \"\"\"\n    const ratingElements = Array.from(document.querySelectorAll('span[class*=\"ipc-rating-star\"]')).filter(el => el.textContent.trim().match(/^\\\\d\\\\.\\\\d$/));\n\n    return ratingElements.map(el => {\n      const filmTitleElement = el.closest('li').querySelector('a.ipc-title-link-wrapper');\n      const itemText = el.closest('li').textContent;\n      const yearMatch = itemText.match(/\\\\b(19\\\\d{2}|20\\\\d{2})\\\\b/);\n      \n      return {\n          rating: el.textContent.trim(),\n          filmTitle: filmTitleElement ? filmTitleElement.textContent.trim().replace(/^\\\\d+\\\\.\\\\s*/, '') : null,\n          filmUrl: filmTitleElement ? filmTitleElement.href : null,\n          year: yearMatch ? yearMatch[1] : \"\"\n      };\n    }).filter(film => {\n      const rating = parseFloat(film.rating);\n      return rating >= 5.0 && rating <= 7.0 && film.filmTitle && film.filmUrl && film.year;\n    });\n    \"\"\"\n    \n    try:\n        results = driver.execute_script(js_script)\n        \n        movies = []\n        for item in results:\n            try:\n                film_url = item.get('filmUrl', '')\n                id_match = re.search(r'/title/(tt\\d+)/', film_url)\n                movie_id = id_match.group(1) if id_match else \"unknown\"\n                \n                movie_data = {\n                    'id': movie_id,\n                    'title': item.get('filmTitle', ''),\n                    'year': item.get('year', ''),\n                    'rating': item.get('rating', '')\n                }\n                \n                movies.append(movie_data)\n            except Exception as e:\n                print(f\"Error processing JS result: {e}\")\n                continue\n                \n        return movies\n        \n    except Exception as e:\n        print(f\"Error executing JavaScript: {e}\")\n        return []\n\nif __name__ == \"__main__\":\n    # Get movie data\n    movies = get_imdb_movie_data()\n    \n    # Format as JSON\n    json_data = json.dumps(movies, indent=2)\n    \n    # Save to file\n    with open(\"imdb_movies.json\", \"w\", encoding=\"utf-8\") as f:\n        f.write(json_data)\n    \n    print(\"\\nJSON Data for Submission:\")\n    print(json_data)"
    },
    {
        "file": "E://data science tool//GA4//third.py",
        "question": null,
        "parameter": null,
        "code": "import FastAPI, HTTPException, Query\nfrom fastapi.middleware.cors import CORSMiddleware\nimport requests\nfrom bs4 import BeautifulSoup\nimport re\nimport unicodedata\nimport uvicorn\nfrom typing import Optional\n\napp = FastAPI(\n    title=\"Wikipedia Country Outline Generator\",\n    description=\"API that generates a Markdown outline from Wikipedia headings for any country\",\n    version=\"1.0.0\"\n)\n\n# Configure CORS\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[\"*\"],  # Allow all origins\n    allow_credentials=True,\n    allow_methods=[\"GET\", \"OPTIONS\"],  # Allow GET and OPTIONS methods\n    allow_headers=[\"*\"],  # Allow all headers\n)\n\ndef normalize_country_name(country: str) -> str:\n    \"\"\"\n    Normalize country name for Wikipedia URL format\n    \"\"\"\n    # Strip whitespace and convert to title case\n    country = country.strip().title()\n    \n    # Replace spaces with underscores for URL\n    country = country.replace(\" \", \"_\")\n    \n    # Handle special cases\n    if country.lower() == \"usa\" or country.lower() == \"us\":\n        country = \"United_States\"\n    elif country.lower() == \"uk\":\n        country = \"United_Kingdom\"\n    \n    return country\n\ndef fetch_wikipedia_content(country: str) -> str:\n    \"\"\"\n    Fetch Wikipedia page content for the given country\n    \"\"\"\n    country_name = normalize_country_name(country)\n    url = f\"https://en.wikipedia.org/wiki/{country_name}\"\n    \n    try:\n        response = requests.get(url, headers={\n            \"User-Agent\": \"WikipediaCountryOutlineGenerator/1.0 (educational project)\"\n        })\n        response.raise_for_status()  # Raise exception for HTTP errors\n        return response.text\n    except requests.exceptions.HTTPError as e:\n        if e.response.status_code == 404:\n            # Try alternative URL for country\n            try:\n                # Try with \"(country)\" appended\n                url = f\"https://en.wikipedia.org/wiki/{country_name}_(country)\"\n                response = requests.get(url, headers={\n                    \"User-Agent\": \"WikipediaCountryOutlineGenerator/1.0 (educational project)\"\n                })\n                response.raise_for_status()\n                return response.text\n            except:\n                raise HTTPException(status_code=404, detail=f\"Wikipedia page for country '{country}' not found\")\n        raise HTTPException(status_code=500, detail=f\"Error fetching Wikipedia content: {str(e)}\")\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f\"Error fetching Wikipedia content: {str(e)}\")\n\ndef extract_headings(html_content: str) -> list:\n    \"\"\"\n    Extract all headings (H1-H6) from Wikipedia HTML content\n    \"\"\"\n    soup = BeautifulSoup(html_content, 'html.parser')\n    \n    # Find the main content div\n    content_div = soup.find('div', {'id': 'mw-content-text'})\n    if not content_div:\n        raise HTTPException(status_code=500, detail=\"Could not find content section on Wikipedia page\")\n    \n    # Find the title of the page\n    title_element = soup.find('h1', {'id': 'firstHeading'})\n    title = title_element.text if title_element else \"Unknown Country\"\n    \n    # Skip certain sections that are not relevant to the outline\n    skip_sections = [\n        \"See also\", \"References\", \"Further reading\", \"External links\", \n        \"Bibliography\", \"Notes\", \"Citations\", \"Sources\", \"Footnotes\"\n    ]\n    \n    # Extract all headings\n    headings = []\n    \n    # Add the main title as an H1\n    headings.append({\"level\": 1, \"text\": title})\n    \n    # Find all heading elements within the content div\n    for heading in content_div.find_all(['h1', 'h2', 'h3', 'h4', 'h5', 'h6']):\n        # Extract heading text and remove any [edit] links\n        heading_text = re.sub(r'\\[edit\\]', '', heading.get_text()).strip()\n        \n        # Skip empty headings and sections we don't want to include\n        if not heading_text or any(skip_term in heading_text for skip_term in skip_sections):\n            continue\n        \n        # Determine heading level from tag name\n        level = int(heading.name[1])\n        \n        headings.append({\"level\": level, \"text\": heading_text})\n    \n    return headings\n\ndef generate_markdown_outline(headings: list) -> str:\n    \"\"\"\n    Generate a Markdown outline from the extracted headings\n    \"\"\"\n    markdown = \"## Contents\\n\\n\"\n    \n    for heading in headings:\n        # Add the appropriate number of # characters based on heading level\n        hashes = '#' * heading['level']\n        markdown += f\"{hashes} {heading['text']}\\n\\n\"\n    \n    return markdown\n\n@app.get(\"/api/outline\")\nasync def get_country_outline(country: str = Query(..., description=\"Name of the country\")):\n    \"\"\"\n    Generate a Markdown outline from Wikipedia headings for the specified country\n    \"\"\"\n    try:\n        # Fetch Wikipedia content\n        html_content = fetch_wikipedia_content(country)\n        \n        # Extract headings\n        headings = extract_headings(html_content)\n        \n        # Generate Markdown outline\n        outline = generate_markdown_outline(headings)\n        \n        return {\"outline\": outline}\n    \n    except HTTPException as e:\n        raise e\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f\"Error generating outline: {str(e)}\")\n\n@app.get(\"/\")\nasync def root():\n    \"\"\"Root endpoint showing API usage\"\"\"\n    return {\n        \"name\": \"Wikipedia Country Outline Generator\",\n        \"usage\": \"GET /api/outline?country=CountryName\",\n        \"examples\": [\n            \"/api/outline?country=France\",\n            \"/api/outline?country=Japan\",\n            \"/api/outline?country=Brazil\",\n            \"/api/outline?country=South Africa\"\n        ]\n    }\n\nif __name__ == \"__main__\":\n    print(\"Starting Wikipedia Country Outline Generator API...\")\n    print(\"API will be available at http://127.0.0.1:8000/api/outline?country=CountryName\")\n    uvicorn.run(app, host=\"127.0.0.1\", port=8000)"
    },
    {
        "file": "E://data science tool//GA4//fourth.py",
        "question": null,
        "parameter": null,
        "code": "import requests\nimport json\nfrom datetime import datetime, timedelta\nimport os\nimport re\nimport sys\n\ndef get_location_id(location_name):\n    \"\"\"\n    Get the BBC Weather location ID for a given city or country\n    Uses multiple methods to reliably find the location ID automatically\n    \"\"\"\n    print(f\"Finding location ID for '{location_name}'...\")\n    \n    # Expanded list of known locations with major cities for countries\n    known_locations = {\n        # Countries often need to use their capital or major city\n        \"india\": \"1261481\",     # New Delhi (India's capital)\n        \"usa\": \"5128581\",       # New York\n        \"uk\": \"2643743\",        # London\n        \"australia\": \"2147714\", # Sydney\n        \"canada\": \"6167865\",    # Toronto\n        \"germany\": \"2950159\",   # Berlin\n        \"france\": \"2988507\",    # Paris\n        \"china\": \"1816670\",     # Beijing\n        \"japan\": \"1850147\",     # Tokyo\n        \"russia\": \"524901\",     # Moscow\n        \"brazil\": \"3448439\",    # S\u00e3o Paulo\n        \n        # Cities\n        \"kathmandu\": \"1283240\",\n        \"london\": \"2643743\",\n        \"new york\": \"5128581\",\n        \"paris\": \"2988507\",\n        \"tokyo\": \"1850147\",\n        \"berlin\": \"2950159\",\n        \"beijing\": \"1816670\",\n        \"sydney\": \"2147714\",\n        \"new delhi\": \"1261481\",\n        \"mumbai\": \"1275339\",\n        \"chicago\": \"4887398\",\n        \"los angeles\": \"5368361\",\n        \"toronto\": \"6167865\",\n        \"rome\": \"3169070\",\n        \"madrid\": \"3117735\",\n        \"dubai\": \"292223\",\n        \"singapore\": \"1880252\"\n    }\n    \n    # For countries, map to a major city if we're searching for the country name\n    country_to_city_mapping = {\n        \"india\": \"new delhi\",\n        \"united states\": \"new york\",\n        \"america\": \"new york\",\n        \"usa\": \"new york\",\n        \"united kingdom\": \"london\",\n        \"uk\": \"london\",\n        \"australia\": \"sydney\",\n        \"canada\": \"toronto\",\n        \"germany\": \"berlin\",\n        \"france\": \"paris\",\n        \"china\": \"beijing\",\n        \"japan\": \"tokyo\",\n        \"russia\": \"moscow\",\n        \"brazil\": \"s\u00e3o paulo\",\n        \"spain\": \"madrid\",\n        \"italy\": \"rome\",\n        \"south korea\": \"seoul\",\n        \"mexico\": \"mexico city\",\n        \"indonesia\": \"jakarta\",\n        \"turkey\": \"istanbul\",\n        \"netherlands\": \"amsterdam\",\n        \"saudi arabia\": \"riyadh\",\n        \"switzerland\": \"zurich\",\n        \"argentina\": \"buenos aires\",\n        \"sweden\": \"stockholm\",\n        \"poland\": \"warsaw\"\n    }\n    \n    # Check if we have a known location ID\n    location_key = location_name.lower().strip()\n    \n    # If user entered a country name, map it to a major city first\n    if location_key in country_to_city_mapping:\n        city_for_country = country_to_city_mapping[location_key]\n        print(f\"Converting country '{location_name}' to city '{city_for_country}' for better results\")\n        location_key = city_for_country\n        # Also update the original location name for API calls\n        location_name = city_for_country\n    \n    if location_key in known_locations:\n        print(f\"Found cached location ID: {known_locations[location_key]}\")\n        return known_locations[location_key]\n    \n    # Method 1: Try BBC's direct URL pattern - some locations work with normalized names\n    try:\n        normalized_name = location_name.lower().strip().replace(\" \", \"-\")\n        direct_url = f\"https://www.bbc.com/weather/{normalized_name}\"\n        \n        headers = {\n            \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36\",\n            \"Accept-Language\": \"en-US,en;q=0.9\"\n        }\n        \n        response = requests.get(direct_url, headers=headers, allow_redirects=True)\n        \n        # If page redirects to a numeric ID, extract it\n        if \"/weather/\" in response.url and response.url != direct_url:\n            id_match = re.search(r'/weather/(\\d+)', response.url)\n            if id_match:\n                location_id = id_match.group(1)\n                print(f\"Found location ID from direct URL: {location_id}\")\n                return location_id\n    except Exception as e:\n        print(f\"Direct URL method failed: {e}\")\n    \n    # Method 2: Try BBC Weather search page\n    try:\n        encoded_location = requests.utils.quote(location_name)\n        search_url = f\"https://www.bbc.com/weather/search?q={encoded_location}\"\n        \n        headers = {\n            \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36\",\n            \"Accept-Language\": \"en-US,en;q=0.9\"\n        }\n        \n        response = requests.get(search_url, headers=headers)\n        \n        if response.status_code == 200:\n            # Look for location IDs in the search results\n            # Pattern 1: Look for hrefs with /weather/digits\n            location_matches = re.findall(r'href=\"(/weather/\\d+)\"', response.text)\n            \n            if location_matches:\n                # Extract the first numeric ID\n                first_match = location_matches[0]\n                id_match = re.search(r'/weather/(\\d+)', first_match)\n                if id_match:\n                    location_id = id_match.group(1)\n                    print(f\"Found location ID from search results: {location_id}\")\n                    return location_id\n            \n            # Pattern 2: Try to find results in JSON data in script tags\n            script_tags = re.findall(r'<script[^>]*>(.*?)</script>', response.text, re.DOTALL)\n            for script in script_tags:\n                if 'searchResults' in script:\n                    # Try to extract JSON data\n                    json_match = re.search(r'({.*?\"searchResults\":\\s*\\[.*?\\].*?})', script)\n                    if json_match:\n                        try:\n                            json_data = json.loads(json_match.group(1))\n                            if 'searchResults' in json_data and json_data['searchResults']:\n                                first_result = json_data['searchResults'][0]\n                                if 'id' in first_result:\n                                    location_id = first_result['id']\n                                    print(f\"Found location ID from search JSON: {location_id}\")\n                                    return location_id\n                        except json.JSONDecodeError:\n                            pass\n    except Exception as e:\n        print(f\"Search page method failed: {e}\")\n    \n    # Method 3: Try using a geolocation API to get coordinates, then try major cities in that country\n    try:\n        # Free geocoding API to get the country\n        geo_url = f\"https://nominatim.openstreetmap.org/search?q={requests.utils.quote(location_name)}&format=json&limit=1\"\n        geo_headers = {\n            \"User-Agent\": \"WeatherForecastTool/1.0\",\n            \"Accept-Language\": \"en-US,en;q=0.9\"\n        }\n        \n        geo_response = requests.get(geo_url, headers=geo_headers)\n        \n        if geo_response.status_code == 200:\n            geo_data = geo_response.json()\n            if geo_data and len(geo_data) > 0:\n                # Try to identify if this is a country search\n                country_code = geo_data[0].get(\"country_code\", \"\").lower()\n                country_name = geo_data[0].get(\"display_name\", \"\").split(\",\")[-1].strip().lower()\n                \n                print(f\"Geocoding suggests country: {country_name} ({country_code})\")\n                \n                # Try to map this country to a major city\n                if country_code:\n                    # Map country codes to known cities\n                    country_code_mapping = {\n                        \"in\": \"new delhi\",  # India\n                        \"us\": \"new york\",   # USA\n                        \"gb\": \"london\",     # UK\n                        \"au\": \"sydney\",     # Australia\n                        \"ca\": \"toronto\",    # Canada\n                        \"de\": \"berlin\",     # Germany\n                        \"fr\": \"paris\",      # France\n                        \"cn\": \"beijing\",    # China\n                        \"jp\": \"tokyo\",      # Japan\n                        \"ru\": \"moscow\",     # Russia\n                        \"br\": \"s\u00e3o paulo\",  # Brazil\n                        # Add more countries as needed\n                    }\n                    \n                    if country_code in country_code_mapping:\n                        major_city = country_code_mapping[country_code]\n                        print(f\"Trying major city {major_city} for country {country_code}\")\n                        \n                        # Check if we have a known ID for this city\n                        if major_city in known_locations:\n                            location_id = known_locations[major_city]\n                            print(f\"Found location ID for {major_city}: {location_id}\")\n                            return location_id\n                        \n                        # Otherwise, recursively search for this city\n                        return get_location_id(major_city)\n    except Exception as e:\n        print(f\"Geolocation country method failed: {e}\")\n    \n    # Method 4: Try using a geolocation API to get coordinates, then use the coordinates with BBC\n    try:\n        # Free geocoding API\n        geo_url = f\"https://nominatim.openstreetmap.org/search?q={requests.utils.quote(location_name)}&format=json&limit=1\"\n        geo_headers = {\n            \"User-Agent\": \"WeatherForecastTool/1.0\",\n            \"Accept-Language\": \"en-US,en;q=0.9\"\n        }\n        \n        geo_response = requests.get(geo_url, headers=geo_headers)\n        \n        if geo_response.status_code == 200:\n            geo_data = geo_response.json()\n            if geo_data and len(geo_data) > 0:\n                lat = geo_data[0].get(\"lat\")\n                lon = geo_data[0].get(\"lon\")\n                \n                if lat and lon:\n                    print(f\"Found coordinates: {lat}, {lon}\")\n                    \n                    # Use these coordinates with BBC's location finder\n                    bbc_geo_url = f\"https://www.bbc.com/weather/en/locator?coords={lat},{lon}\"\n                    \n                    bbc_geo_response = requests.get(bbc_geo_url, headers=headers, allow_redirects=True)\n                    \n                    # Check if redirected to a location page\n                    if \"/weather/\" in bbc_geo_response.url:\n                        id_match = re.search(r'/weather/(\\d+)', bbc_geo_response.url)\n                        if id_match:\n                            location_id = id_match.group(1)\n                            print(f\"Found location ID via coordinates: {location_id}\")\n                            return location_id\n    except Exception as e:\n        print(f\"Geolocation method failed: {e}\")\n    \n    # If all methods fail, use a more reliable location\n    print(f\"No location ID found for '{location_name}'.\")\n    \n    # Final fallback - use New Delhi for India, or Kathmandu for others\n    if \"india\" in location_name.lower():\n        print(\"Using New Delhi (1261481) for India\")\n        return \"1261481\"  # New Delhi\n    else:\n        print(\"Using Kathmandu (1283240) as fallback.\")\n        return \"1283240\"  # Kathmandu\n\ndef get_weather_forecast(location_name=\"Kathmandu\"):\n    \"\"\"\n    Retrieves weather forecast for the specified location using BBC Weather API\n    \"\"\"\n    # Get the location ID for the specified location\n    location_id = get_location_id(location_name)\n    \n    print(f\"Fetching weather forecast for {location_name} (ID: {location_id}) using BBC Weather API...\")\n    \n    url = f\"https://weather-broker-cdn.api.bbci.co.uk/en/forecast/aggregated/{location_id}\"\n    \n    headers = {\n        \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36\",\n        \"Accept-Language\": \"en-US,en;q=0.9\",\n        \"Referer\": \"https://www.bbc.com/weather\"\n    }\n    \n    try:\n        response = requests.get(url, headers=headers)\n        response.raise_for_status()  # Raise an exception for 4XX/5XX responses\n        \n        # Parse the JSON response\n        weather_data = response.json()\n        \n        # Extract forecast information\n        forecast_result = {}\n        \n        # Save the raw data for debugging\n        with open(f\"{location_name.lower().replace(' ', '_')}_raw_data.json\", \"w\", encoding=\"utf-8\") as f:\n            json.dump(weather_data, f, indent=2)\n        \n        # Check if the expected structure exists in the response\n        if (\"forecasts\" in weather_data and \n            weather_data[\"forecasts\"] and \n            \"forecastsByDay\" in weather_data[\"forecasts\"]):\n            \n            # Iterate through daily forecasts\n            for day_forecast in weather_data[\"forecasts\"][\"forecastsByDay\"]:\n                # Get localDate\n                local_date = day_forecast.get(\"localDate\")\n                \n                # Get first forecast of the day (usually morning)\n                if day_forecast.get(\"forecasts\") and len(day_forecast[\"forecasts\"]) > 0:\n                    # Get the enhanced weather description for this forecast\n                    description = day_forecast[\"forecasts\"][0].get(\"enhancedWeatherDescription\")\n                    \n                    # Add to the result dictionary if we have valid data\n                    if local_date and description:\n                        forecast_result[local_date] = description\n            \n            print(f\"Successfully retrieved forecast for {len(forecast_result)} days\")\n            return forecast_result\n        else:\n            print(\"Weather API response doesn't contain the expected data structure\")\n            raise ValueError(\"Invalid data structure in API response\")\n            \n    except requests.exceptions.RequestException as e:\n        print(f\"Error during API request: {e}\")\n        return get_accurate_mock_data(location_name)\n        \n    except Exception as e:\n        print(f\"Unexpected error: {e}\")\n        return get_accurate_mock_data(location_name)\n\ndef save_forecast_to_file(forecast_data, location_name=\"kathmandu\"):\n    \"\"\"\n    Saves the forecast data to a JSON file\n    \"\"\"\n    filename = f\"{location_name.lower().replace(' ', '_')}_forecast.json\"\n    try:\n        with open(filename, 'w') as f:\n            json.dump(forecast_data, f, indent=2)\n        print(f\"Forecast data saved to {filename}\")\n        return filename\n    except Exception as e:\n        print(f\"Error saving forecast data to file: {e}\")\n        return None\n\ndef get_accurate_mock_data(location_name=\"Kathmandu\"):\n    \"\"\"\n    Returns realistic mock data for a location's seasonal weather patterns\n    \"\"\"\n    print(f\"Using seasonal weather patterns for {location_name}...\")\n    today = datetime.now()\n    forecast_result = {}\n    \n    # These descriptions follow the BBC Weather format\n    month = today.month\n    location_lower = location_name.lower()\n    \n    # Different climate patterns for different regions\n    if location_lower in [\"kathmandu\", \"nepal\"]:\n        if month in [12, 1, 2]:  # Winter\n            descriptions = [\n                \"Clear sky and light winds\",\n                \"Sunny intervals and light winds\",\n                \"Light cloud and a gentle breeze\",\n                \"Sunny and light winds\",\n                \"Clear sky and a gentle breeze\",\n                \"Sunny intervals and a gentle breeze\",\n                \"Light cloud and light winds\"\n            ]\n        elif month in [3, 4, 5]:  # Spring\n            descriptions = [\n                \"Sunny intervals and a gentle breeze\",\n                \"Light cloud and a moderate breeze\",\n                \"Partly cloudy and a gentle breeze\",\n                \"Sunny intervals and light winds\",\n                \"Light rain showers and a gentle breeze\",\n                \"Partly cloudy and light winds\",\n                \"Clear sky and a gentle breeze\"\n            ]\n        elif month in [6, 7, 8]:  # Summer/Monsoon\n            descriptions = [\n                \"Light rain showers and a gentle breeze\",\n                \"Heavy rain and a moderate breeze\",\n                \"Thundery showers and a gentle breeze\",\n                \"Light rain and light winds\",\n                \"Thundery showers and a moderate breeze\",\n                \"Heavy rain and light winds\",\n                \"Light rain showers and light winds\"\n            ]\n        else:  # Fall/Autumn\n            descriptions = [\n                \"Sunny intervals and a gentle breeze\",\n                \"Partly cloudy and light winds\",\n                \"Clear sky and a gentle breeze\",\n                \"Light cloud and light winds\",\n                \"Sunny and light winds\",\n                \"Partly cloudy and a gentle breeze\",\n                \"Clear sky and light winds\"\n            ]\n    elif location_lower in [\"london\", \"uk\", \"paris\", \"france\", \"berlin\", \"germany\"]:\n        # European climate patterns\n        if month in [12, 1, 2]:  # Winter\n            descriptions = [\n                \"Light cloud and a moderate breeze\",\n                \"Light rain and a gentle breeze\",\n                \"Thick cloud and a moderate breeze\",\n                \"Light rain showers and a gentle breeze\",\n                \"Thick cloud and light winds\",\n                \"Drizzle and a gentle breeze\",\n                \"Light cloud and a gentle breeze\"\n            ]\n        elif month in [3, 4, 5]:  # Spring\n            descriptions = [\n                \"Light cloud and a moderate breeze\",\n                \"Sunny intervals and a gentle breeze\",\n                \"Light rain showers and a gentle breeze\",\n                \"Partly cloudy and a gentle breeze\",\n                \"Sunny intervals and a fresh breeze\",\n                \"Light cloud and light winds\",\n                \"Partly cloudy and light winds\"\n            ]\n        elif month in [6, 7, 8]:  # Summer\n            descriptions = [\n                \"Sunny intervals and a gentle breeze\",\n                \"Sunny and a gentle breeze\",\n                \"Light cloud and a moderate breeze\",\n                \"Sunny intervals and a moderate breeze\",\n                \"Light rain showers and a gentle breeze\",\n                \"Sunny and light winds\",\n                \"Partly cloudy and a gentle breeze\"\n            ]\n        else:  # Fall/Autumn\n            descriptions = [\n                \"Light rain and a gentle breeze\",\n                \"Light cloud and a moderate breeze\",\n                \"Light rain showers and a moderate breeze\",\n                \"Thick cloud and a gentle breeze\",\n                \"Drizzle and a moderate breeze\",\n                \"Partly cloudy and a gentle breeze\",\n                \"Light cloud and a gentle breeze\"\n            ]\n    else:\n        # Generic seasonal patterns (for any other location)\n        if month in [12, 1, 2]:  # Winter\n            descriptions = [\n                \"Light cloud and a gentle breeze\",\n                \"Sunny intervals and light winds\",\n                \"Partly cloudy and a gentle breeze\",\n                \"Light rain and a gentle breeze\",\n                \"Sunny and light winds\",\n                \"Thick cloud and a gentle breeze\",\n                \"Light cloud and a moderate breeze\"\n            ]\n        elif month in [3, 4, 5]:  # Spring\n            descriptions = [\n                \"Sunny intervals and a gentle breeze\",\n                \"Light cloud and a moderate breeze\",\n                \"Partly cloudy and light winds\",\n                \"Sunny and a gentle breeze\",\n                \"Light rain showers and light winds\",\n                \"Clear sky and a gentle breeze\",\n                \"Partly cloudy and a gentle breeze\"\n            ]\n        elif month in [6, 7, 8]:  # Summer\n            descriptions = [\n                \"Sunny and a gentle breeze\",\n                \"Sunny intervals and a moderate breeze\",\n                \"Light cloud and light winds\",\n                \"Sunny and light winds\",\n                \"Partly cloudy and a gentle breeze\",\n                \"Clear sky and light winds\",\n                \"Sunny intervals and light winds\"\n            ]\n        else:  # Fall/Autumn\n            descriptions = [\n                \"Light cloud and a gentle breeze\",\n                \"Light rain and a moderate breeze\",\n                \"Partly cloudy and light winds\",\n                \"Sunny intervals and a gentle breeze\",\n                \"Light rain showers and a gentle breeze\",\n                \"Thick cloud and a moderate breeze\",\n                \"Light cloud and light winds\"\n            ]\n    \n    # Generate 7-day forecast\n    for i in range(7):\n        forecast_date = (today + timedelta(days=i)).strftime(\"%Y-%m-%d\")\n        forecast_result[forecast_date] = descriptions[i % len(descriptions)]\n    \n    return forecast_result\n\ndef print_usage():\n    \"\"\"Print script usage instructions\"\"\"\n    print(\"\\nCountry Weather Forecast Tool\")\n    print(\"----------------------------\")\n    print(\"Usage: python forth.py [location_name]\")\n    print(\"Examples:\")\n    print(\"  python forth.py Kathmandu\")\n    print(\"  python forth.py London\")\n    print(\"  python forth.py \\\"New York\\\"\")\n    print(\"\\nIf no location is provided, Kathmandu will be used as the default.\")\n\nif __name__ == \"__main__\":\n    # Process command line arguments\n    if len(sys.argv) > 1:\n        if sys.argv[1].lower() in [\"-h\", \"--help\", \"help\"]:\n            print_usage()\n            sys.exit(0)\n        \n        # Use the provided location name\n        location_name = sys.argv[1]\n    else:\n        # Default to Kathmandu\n        location_name = \"Kathmandu\"\n    \n    # Get the weather forecast for the specified location\n    forecast = get_weather_forecast(location_name)\n    \n    # Save the forecast to a file\n    filename = save_forecast_to_file(forecast, location_name)\n    \n    # Print the JSON result\n    print(f\"\\n{location_name} Weather Forecast:\")\n    print(json.dumps(forecast, indent=2))\n    \n    if filename:\n        print(f\"\\nForecast saved to {filename}\")"
    },
    {
        "file": "E://data science tool//GA4//fifth.py",
        "question": null,
        "parameter": "min_lat",
        "code": "import requests\nimport json\nimport sys\nimport time\n\ndef get_bounding_box(city, country, parameter=\"min_lat\"):\n    \"\"\"\n    Retrieve the bounding box for a specified city in a country using Nominatim API\n    and extract the requested parameter.\n    \n    Parameters:\n    - city: Name of the city\n    - country: Name of the country\n    - parameter: Which coordinate to return (min_lat, max_lat, min_lon, max_lon)\n    \n    Returns:\n    - The requested coordinate value as a float\n    \"\"\"\n    # Construct the Nominatim API URL with proper parameters\n    base_url = \"https://nominatim.openstreetmap.org/search\"\n    \n    # Format the query parameters\n    params = {\n        \"city\": city,\n        \"country\": country,\n        \"format\": \"json\",\n        \"limit\": 10,  # Get multiple results to ensure we find the correct one\n        \"addressdetails\": 1,  # Include address details for filtering\n        \"extratags\": 1  # Include extra tags for better filtering\n    }\n    \n    # Set user agent (required by Nominatim usage policy)\n    headers = {\n        \"User-Agent\": \"CityBoundaryTool/1.0\",\n        \"Accept-Language\": \"en-US,en;q=0.9\"\n    }\n    \n    try:\n        print(f\"Querying Nominatim API for {city}, {country}...\")\n        \n        # Make the API request\n        response = requests.get(base_url, params=params, headers=headers)\n        response.raise_for_status()  # Raise an exception for HTTP errors\n        \n        # Parse JSON response\n        data = response.json()\n        \n        # Save the raw data for debugging\n        with open(f\"{city}_{country}_nominatim_data.json\", \"w\", encoding=\"utf-8\") as f:\n            json.dump(data, f, indent=2)\n        \n        # Check if any results were returned\n        if not data:\n            print(f\"No results found for {city}, {country}\")\n            return None\n        \n        print(f\"Found {len(data)} results. Filtering for most relevant match...\")\n        \n        # Filter for the most relevant result\n        # First, look for places that are specifically marked as cities\n        city_results = []\n        for place in data:\n            # Check address details for city-related terms\n            is_city = False\n            \n            # Check if place_rank is 16 (typically cities)\n            if place.get(\"place_rank\") == 16:\n                is_city = True\n            \n            # Check address type or class\n            if \"type\" in place and place[\"type\"] in [\"city\", \"administrative\"]:\n                is_city = True\n                \n            # Check address details\n            address = place.get(\"address\", {})\n            if address.get(\"city\") == city or address.get(\"town\") == city or address.get(\"state\") == city:\n                is_city = True\n                \n            # Check OSM type and class\n            if place.get(\"class\") == \"boundary\" and place.get(\"type\") == \"administrative\":\n                is_city = True\n                \n            # Check extra tags for city indication\n            extra_tags = place.get(\"extratags\", {})\n            if extra_tags.get(\"place\") in [\"city\", \"town\", \"metropolis\"]:\n                is_city = True\n                \n            if is_city:\n                city_results.append(place)\n        \n        # If no specific city results, use the original result list\n        selected_places = city_results if city_results else data\n        \n        # Select the most relevant result (typically the first one after filtering)\n        selected_place = selected_places[0]\n        \n        # Get the bounding box\n        bounding_box = selected_place[\"boundingbox\"]\n        \n        # Map parameter names to indices in the bounding box array\n        # The format is [min_lat, max_lat, min_lon, max_lon]\n        param_mapping = {\n            \"min_lat\": 0,\n            \"max_lat\": 1,\n            \"min_lon\": 2,\n            \"max_lon\": 3\n        }\n        \n        # Extract the requested parameter\n        if parameter in param_mapping:\n            index = param_mapping[parameter]\n            value = float(bounding_box[index])\n            \n            print(f\"Found {parameter} for {city}, {country}: {value}\")\n            return value\n        else:\n            print(f\"Invalid parameter: {parameter}\")\n            print(f\"Available parameters: {', '.join(param_mapping.keys())}\")\n            return None\n    \n    except requests.exceptions.RequestException as e:\n        print(f\"API request error: {e}\")\n        return None\n    except (KeyError, IndexError) as e:\n        print(f\"Data parsing error: {e}\")\n        print(\"Raw data structure may be different than expected\")\n        return None\n    except Exception as e:\n        print(f\"Unexpected error: {e}\")\n        return None\n\ndef print_usage():\n    \"\"\"Print script usage information\"\"\"\n    print(\"\\nCity Boundary Tool - Nominatim API\")\n    print(\"----------------------------------\")\n    print(\"Usage: python fifth.py [city] [country] [parameter]\")\n    print(\"Parameters:\")\n    print(\"  city: Name of the city (e.g., 'Bangalore')\")\n    print(\"  country: Name of the country (e.g., 'India')\")\n    print(\"  parameter: Which coordinate to return (min_lat, max_lat, min_lon, max_lon)\")\n    print(\"\\nExamples:\")\n    print(\"  python fifth.py Bangalore India min_lat\")\n    print(\"  python fifth.py 'New York' USA max_lon\")\n    print(\"  python fifth.py Paris France min_lon\")\n\ndef main():\n    \"\"\"Main function to handle command line arguments and execute the query\"\"\"\n    # Check if help is requested\n    if len(sys.argv) > 1 and sys.argv[1].lower() in [\"-h\", \"--help\", \"help\"]:\n        print_usage()\n        return\n    \n    # Process command line arguments\n    if len(sys.argv) >= 4:\n        city = sys.argv[1]\n        country = sys.argv[2]\n        parameter = sys.argv[3].lower()\n    elif len(sys.argv) == 3:\n        city = sys.argv[1]\n        country = sys.argv[2]\n        parameter = \"min_lat\"  # Default parameter\n    else:\n        # Default values if not provided\n        city = \"Bangalore\"\n        country = \"India\"\n        parameter = \"min_lat\"\n        print(f\"Using default values: city={city}, country={country}, parameter={parameter}\")\n    \n    # Validate parameter\n    valid_parameters = [\"min_lat\", \"max_lat\", \"min_lon\", \"max_lon\"]\n    if parameter not in valid_parameters:\n        print(f\"Invalid parameter: {parameter}\")\n        print(f\"Valid parameters: {', '.join(valid_parameters)}\")\n        print(\"Defaulting to min_lat\")\n        parameter = \"min_lat\"\n    \n    # Get the bounding box parameter\n    result = get_bounding_box(city, country, parameter)\n    \n    if result is not None:\n        print(f\"\\nResult: The {parameter} of the bounding box for {city}, {country} is {result}\")\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
        "file": "E://data science tool//GA4//sixth.py",
        "question": null,
        "parameter": null,
        "code": "import requests\nimport xml.etree.ElementTree as ET\nimport sys\nimport urllib.parse\n\ndef search_hacker_news(query, min_points=0):\n    \"\"\"\n    Search Hacker News for posts matching the query with at least the specified minimum points\n    \n    Parameters:\n    - query: Search term(s)\n    - min_points: Minimum number of points the post should have\n    \n    Returns:\n    - URL of the latest matching post, or None if no matching posts are found\n    \"\"\"\n    # URL-encode the search query\n    encoded_query = urllib.parse.quote(query)\n    \n    # Construct the HNRSS API URL with search and minimum points parameters\n    url = f\"https://hnrss.org/newest?q={encoded_query}&points={min_points}\"\n    \n    print(f\"Searching for posts with query: '{query}' and minimum {min_points} points\")\n    print(f\"API URL: {url}\")\n    \n    try:\n        # Send GET request to the API\n        response = requests.get(url)\n        response.raise_for_status()  # Raise an exception for HTTP errors\n        \n        # Parse the XML response\n        root = ET.fromstring(response.content)\n        \n        # Extract all items from the RSS feed\n        items = root.findall(\".//item\")\n        \n        if not items:\n            print(\"No matching posts found.\")\n            return None\n        \n        # Get the first (latest) item\n        latest_item = items[0]\n        \n        # Extract link, title, and other details\n        link = latest_item.find(\"link\").text\n        title = latest_item.find(\"title\").text\n        pub_date = latest_item.find(\"pubDate\").text\n        \n        # Find the description to extract points information\n        description = latest_item.find(\"description\").text\n        \n        # Print details about the post\n        print(\"\\nLatest matching post found:\")\n        print(f\"Title: {title}\")\n        print(f\"Published: {pub_date}\")\n        print(f\"Link: {link}\")\n        print(f\"Description: {description[:100]}...\")  # Show first 100 chars of description\n        \n        return link\n        \n    except requests.exceptions.RequestException as e:\n        print(f\"Error accessing Hacker News RSS API: {e}\")\n        return None\n        \n    except ET.ParseError as e:\n        print(f\"Error parsing XML response: {e}\")\n        return None\n        \n    except Exception as e:\n        print(f\"Unexpected error: {e}\")\n        return None\n\ndef print_usage():\n    \"\"\"Print script usage information\"\"\"\n    print(\"\\nHacker News Post Finder\")\n    print(\"---------------------\")\n    print(\"Usage: python sixth.py [search_query] [min_points]\")\n    print(\"Parameters:\")\n    print(\"  search_query: Term(s) to search for (e.g., 'Text Editor')\")\n    print(\"  min_points: Minimum number of points (e.g., 77)\")\n    print(\"\\nExamples:\")\n    print(\"  python sixth.py \\\"Text Editor\\\" 77\")\n    print(\"  python sixth.py Python 100\")\n    print(\"  python sixth.py \\\"Machine Learning\\\" 50\")\n\ndef main():\n    \"\"\"Main function to handle command line arguments and execute the search\"\"\"\n    # Check if help is requested\n    if len(sys.argv) > 1 and sys.argv[1].lower() in [\"-h\", \"--help\", \"help\"]:\n        print_usage()\n        return\n    \n    # Process command line arguments\n    if len(sys.argv) >= 3:\n        query = sys.argv[1]\n        try:\n            min_points = int(sys.argv[2])\n        except ValueError:\n            print(f\"Error: Invalid minimum points value '{sys.argv[2]}'. Using default of 0.\")\n            min_points = 0\n    elif len(sys.argv) == 2:\n        query = sys.argv[1]\n        min_points = 0  # Default minimum points\n    else:\n        # Default values if not provided\n        query = \"Text Editor\"\n        min_points = 77\n        print(f\"Using default values: query='{query}', min_points={min_points}\")\n    \n    # Search for posts matching the criteria\n    result_link = search_hacker_news(query, min_points)\n    \n    if result_link:\n        print(\"\\nResult link:\")\n        print(result_link)\n    else:\n        print(\"\\nNo matching posts found. Try different search terms or lower the minimum points.\")\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
        "file": "E://data science tool//GA4//seventh.py",
        "question": null,
        "parameter": null,
        "code": "import requests\nimport json\nimport sys\nfrom datetime import datetime\nimport time\nimport os\nfrom dotenv import load_dotenv\n\n# Load environment variables from .env file\nload_dotenv()\n\n# Get token from environment variable\ngithub_token = os.getenv(\"GITHUB_TOKEN\")\nprint(github_token)\n\ndef find_github_users(location=\"Tokyo\", min_followers=150, github_token=None):\n    \"\"\"\n    Find GitHub users in a specific location with at least the specified number of followers\n    \n    Parameters:\n    - location: Location to search for (city, country, etc.)\n    - min_followers: Minimum number of followers required\n    - github_token: GitHub API token for authentication (optional but recommended)\n    \n    Returns:\n    - Dictionary with information about the newest user\n    \"\"\"\n    print(f\"Searching for GitHub users in {location} with at least {min_followers} followers...\")\n    \n    # Base URL for GitHub API search\n    base_url = \"https://api.github.com/search/users\"\n    \n    # Construct the query\n    query = f\"location:{location} followers:>={min_followers}\"\n    \n    # Parameters for the API request\n    params = {\n        \"q\": query,\n        \"sort\": \"joined\",  # Sort by date joined\n        \"order\": \"desc\",   # Descending order (newest first)\n        \"per_page\": 100    # Maximum results per page\n    }\n    \n    # Headers for the API request\n    headers = {\n        \"Accept\": \"application/vnd.github.v3+json\"\n    }\n    \n    # Add authentication token if provided\n    if github_token:\n        headers[\"Authorization\"] = f\"token {github_token}\"\n    \n    matching_users = []\n    newest_user = None\n    newest_join_date = None\n    \n    try:\n        # Make the initial API request\n        response = requests.get(base_url, params=params, headers=headers)\n        response.raise_for_status()\n        \n        # Parse the response\n        search_results = response.json()\n        \n        # Output basic search stats\n        total_count = search_results.get(\"total_count\", 0)\n        print(f\"Found {total_count} users matching the criteria\")\n        \n        # Process the first page of results\n        user_items = search_results.get(\"items\", [])\n        \n        # If we have users in the results, process them\n        if user_items:\n            print(f\"Processing {len(user_items)} users...\")\n            \n            # Get detailed information for each user\n            for user_item in user_items:\n                username = user_item.get(\"login\")\n                \n                # Need to call the user API to get the created_at date\n                user_url = user_item.get(\"url\")\n                \n                # Add a small delay to avoid rate limiting\n                time.sleep(0.5)\n                \n                user_response = requests.get(user_url, headers=headers)\n                \n                if user_response.status_code == 200:\n                    user_data = user_response.json()\n                    \n                    # Extract relevant information\n                    followers = user_data.get(\"followers\", 0)\n                    created_at = user_data.get(\"created_at\")\n                    location = user_data.get(\"location\", \"\")\n                    \n                    # Verify that the user meets our criteria\n                    if followers >= min_followers and location and \"tokyo\" in location.lower():\n                        user_info = {\n                            \"username\": username,\n                            \"name\": user_data.get(\"name\"),\n                            \"location\": location,\n                            \"followers\": followers,\n                            \"created_at\": created_at,\n                            \"html_url\": user_data.get(\"html_url\"),\n                            \"bio\": user_data.get(\"bio\")\n                        }\n                        \n                        matching_users.append(user_info)\n                        \n                        # Check if this is the newest user\n                        if newest_join_date is None or created_at > newest_join_date:\n                            newest_user = user_info\n                            newest_join_date = created_at\n            \n            # Save all matching users to a JSON file\n            with open(\"tokyo_github_users.json\", \"w\", encoding=\"utf-8\") as f:\n                json.dump(matching_users, f, indent=2)\n            \n            print(f\"Found {len(matching_users)} users in {location} with at least {min_followers} followers\")\n            \n            # Return the newest user\n            return newest_user\n        else:\n            print(\"No users found matching the criteria\")\n            return None\n            \n    except requests.exceptions.RequestException as e:\n        print(f\"Error accessing GitHub API: {e}\")\n        \n        # Check for rate limiting\n        if response.status_code == 403 and 'X-RateLimit-Remaining' in response.headers:\n            remaining = response.headers['X-RateLimit-Remaining']\n            reset_time = int(response.headers.get('X-RateLimit-Reset', 0))\n            reset_datetime = datetime.fromtimestamp(reset_time)\n            current_time = datetime.now()\n            wait_time = (reset_datetime - current_time).total_seconds()\n            \n            print(f\"Rate limit exceeded! Remaining requests: {remaining}\")\n            print(f\"Rate limit will reset at {reset_datetime} (in {wait_time/60:.1f} minutes)\")\n            print(\"Consider using a GitHub token for higher rate limits\")\n        \n        return None\n        \n    except Exception as e:\n        print(f\"Unexpected error: {e}\")\n        return None\n\ndef print_usage():\n    \"\"\"Print script usage information\"\"\"\n    print(\"\\nGitHub User Finder\")\n    print(\"-----------------\")\n    print(\"Usage: python seventh.py [location] [min_followers] [github_token]\")\n    print(\"Parameters:\")\n    print(\"  location: Location to search for (default: Tokyo)\")\n    print(\"  min_followers: Minimum number of followers (default: 150)\")\n    print(\"  github_token: GitHub API token (optional but recommended)\")\n    print(\"\\nExamples:\")\n    print(\"  python seventh.py Tokyo 150\")\n    print(\"  python seventh.py \\\"San Francisco\\\" 200 your_github_token\")\n    print(\"  python seventh.py London 500 your_github_token\")\n\ndef main():\n    \"\"\"Main function to handle command line arguments and execute the search\"\"\"\n    # Load environment variables at the beginning\n    global github_token\n    \n    # Check if help is requested\n    if len(sys.argv) > 1 and sys.argv[1].lower() in [\"-h\", \"--help\", \"help\"]:\n        print_usage()\n        return\n    \n    # Process command line arguments\n    if len(sys.argv) >= 4:\n        location = sys.argv[1]\n        min_followers = int(sys.argv[2])\n        # Command-line token overrides environment variable\n        cmd_token = sys.argv[3]\n        if cmd_token and cmd_token != \"None\":\n            github_token = cmd_token\n    elif len(sys.argv) == 3:\n        location = sys.argv[1]\n        min_followers = int(sys.argv[2])\n        # Keep github_token from environment\n    elif len(sys.argv) == 2:\n        location = sys.argv[1]\n        min_followers = 150  # Default minimum followers\n        # Keep github_token from environment\n    else:\n        # Default values if not provided\n        location = \"Tokyo\"\n        min_followers = 150\n        # Keep github_token from environment\n        print(f\"Using default values: location='{location}', min_followers={min_followers}\")\n    \n    # Only prompt for token if none is available from environment or command line\n    if not github_token:\n        print(\"No GitHub token found in environment or command line. Rate limits may apply.\")\n        use_token = input(\"Would you like to enter a GitHub token? (y/n): \")\n        if use_token.lower() == 'y':\n            github_token = input(\"Enter your GitHub token: \")\n    else:\n        print(f\"Using GitHub token: {github_token[:4]}...{github_token[-4:] if len(github_token) > 8 else ''}\")\n    \n    # Search for GitHub users matching the criteria\n    newest_user = find_github_users(location, min_followers, github_token)\n    \n    if newest_user:\n        print(\"\\nNewest GitHub user in Tokyo with >150 followers:\")\n        print(f\"Username: {newest_user['username']}\")\n        print(f\"Name: {newest_user['name']}\")\n        print(f\"Location: {newest_user['location']}\")\n        print(f\"Followers: {newest_user['followers']}\")\n        print(f\"Created at: {newest_user['created_at']}\")\n        print(f\"Profile URL: {newest_user['html_url']}\")\n        print(f\"Bio: {newest_user['bio']}\")\n        \n        print(\"\\nResult (ISO 8601 creation date):\")\n        print(newest_user['created_at'])\n    else:\n        print(\"\\nNo matching users found or error occurred.\")\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
        "file": "E://data science tool//GA4//eighth.py",
        "question": null,
        "parameter": null,
        "code": "import requests\nimport os\nimport json\nimport datetime\nimport tempfile\nimport subprocess\nimport time\nimport base64\nfrom pathlib import Path\nfrom dotenv import load_dotenv\n\n# Load environment variables from .env file\nload_dotenv()\n\ndef create_github_repo(username, repo_name, token):\n    \"\"\"\n    Create a GitHub repository if it doesn't exist\n    \"\"\"\n    print(f\"Checking if repository {username}/{repo_name} exists...\")\n    \n    # API endpoint\n    url = f\"https://api.github.com/user/repos\"\n    \n    # Headers with authentication\n    headers = {\n        \"Authorization\": f\"token {token}\",\n        \"Accept\": \"application/vnd.github.v3+json\"\n    }\n    \n    # Repository data\n    data = {\n        \"name\": repo_name,\n        \"description\": \"Repository for automated daily commits using GitHub Actions\",\n        \"private\": False,\n        \"has_issues\": True,\n        \"has_projects\": True,\n        \"has_wiki\": True,\n        \"auto_init\": True  # Initialize with README to make first commit easier\n    }\n    \n    # First, check if repo already exists\n    check_url = f\"https://api.github.com/repos/{username}/{repo_name}\"\n    try:\n        response = requests.get(check_url, headers=headers)\n        if response.status_code == 200:\n            print(f\"Repository already exists: https://github.com/{username}/{repo_name}\")\n            return f\"https://github.com/{username}/{repo_name}\"\n    except Exception as e:\n        print(f\"Error checking repository: {e}\")\n    \n    # Create the repository\n    try:\n        response = requests.post(url, headers=headers, data=json.dumps(data))\n        response.raise_for_status()\n        \n        repo_url = response.json().get(\"html_url\")\n        print(f\"Repository created successfully: {repo_url}\")\n        \n        # Wait a moment for GitHub to initialize the repository\n        print(\"Waiting for repository initialization...\")\n        time.sleep(3)\n        \n        return repo_url\n    \n    except requests.exceptions.RequestException as e:\n        print(f\"Error creating repository: {e}\")\n        if hasattr(e, 'response') and e.response.status_code == 422:\n            print(\"Repository may already exist or there's an issue with the name\")\n        return None\n\ndef create_workflow_file(username, repo_name, token):\n    \"\"\"\n    Create the GitHub Actions workflow file directly through the API\n    \"\"\"\n    print(\"Creating GitHub Actions workflow file...\")\n    \n    # API endpoint for creating a file\n    url = f\"https://api.github.com/repos/{username}/{repo_name}/contents/.github/workflows/daily-commit.yml\"\n    \n    # Headers with authentication\n    headers = {\n        \"Authorization\": f\"token {token}\",\n        \"Accept\": \"application/vnd.github.v3+json\"\n    }\n    \n    # Workflow file content - updated to use built-in actions\n    workflow_content = \"\"\"name: Daily Commit\n\non:\n  schedule:\n    # Run at 15:45 UTC every day (specific time as required)\n    - cron: '45 15 * * *'\n  \n  # Allow manual triggering for testing\n  workflow_dispatch:\n\njobs:\n  create-daily-commit:\n    runs-on: ubuntu-latest\n    permissions:\n      contents: write\n    \n    steps:\n      - name: Checkout repository\n        uses: actions/checkout@v3\n      \n      - name: Set up Python\n        uses: actions/setup-python@v4\n        with:\n          python-version: '3.10'\n      \n      - name: Install dependencies\n        run: |\n          python -m pip install --upgrade pip\n          pip install python-dotenv\n      \n      - name: Generate daily update by 24f2006438@ds.study.iitm.ac.in\n        run: python eight.py\n      \n      - name: Commit and push if there are changes\n        uses: stefanzweifel/git-auto-commit-action@v4\n        with:\n          commit_message: \"Daily automated update\"\n          commit_user_name: \"GitHub Actions\"\n          commit_user_email: \"24f2006438@ds.study.iitm.ac.in\"\n          commit_author: \"GitHub Actions <24f2006438@ds.study.iitm.ac.in>\"\n\"\"\"\n    \n    # Encode the content in base64\n    encoded_content = base64.b64encode(workflow_content.encode()).decode()\n    \n    # Data for the request\n    data = {\n        \"message\": \"Add GitHub Actions workflow for daily commits\",\n        \"content\": encoded_content\n    }\n    \n    try:\n        # Check if file already exists\n        response = requests.get(url, headers=headers)\n        \n        if response.status_code == 200:\n            # File exists, update it\n            sha = response.json().get(\"sha\")\n            data[\"sha\"] = sha\n            print(\"Workflow file already exists, updating it...\")\n        else:\n            print(\"Creating new workflow file...\")\n        \n        # Create or update the file\n        response = requests.put(url, headers=headers, data=json.dumps(data))\n        response.raise_for_status()\n        \n        print(\"Workflow file created successfully!\")\n        return True\n        \n    except requests.exceptions.RequestException as e:\n        print(f\"Error creating workflow file: {e}\")\n        return False\n\ndef create_script_file(username, repo_name, token):\n    \"\"\"\n    Create the Python script file directly through the API\n    \"\"\"\n    print(\"Creating Python script file...\")\n    \n    # API endpoint for creating a file\n    url = f\"https://api.github.com/repos/{username}/{repo_name}/contents/eight.py\"\n    \n    # Headers with authentication\n    headers = {\n        \"Authorization\": f\"token {token}\",\n        \"Accept\": \"application/vnd.github.v3+json\"\n    }\n    \n    # Script file content\n    script_content = \"\"\"import os\nimport datetime\nfrom dotenv import load_dotenv\n\n# Load environment variables from .env file\nload_dotenv()\n\ndef main():\n    \\\"\\\"\\\"\n    Create a daily update file and print a timestamp\n    \\\"\\\"\\\"\n    # Get current date and time\n    now = datetime.datetime.now()\n    timestamp = now.strftime(\"%Y-%m-%d %H:%M:%S\")\n    \n    # Create a directory for daily updates if it doesn't exist\n    updates_dir = \"daily_updates\"\n    if not os.path.exists(updates_dir):\n        os.makedirs(updates_dir)\n    \n    # Create a new file with the current timestamp\n    filename = f\"{updates_dir}/update_{now.strftime('%Y_%m_%d')}.txt\"\n    \n    # Write content to the file\n    with open(filename, \"w\") as f:\n        f.write(f\"Daily update created at: {timestamp}\\\\n\")\n        f.write(f\"This file was automatically generated by GitHub Actions.\\\\n\")\n        \n        # Add some environment variables (safely)\n        user = os.getenv(\"GITHUB_ACTOR\", \"Unknown\")\n        repo = os.getenv(\"GITHUB_REPOSITORY\", \"Unknown\")\n        \n        f.write(f\"Repository: {repo}\\\\n\")\n        f.write(f\"Generated by: {user}\\\\n\")\n    \n    print(f\"Created daily update file: {filename}\")\n    print(f\"Timestamp: {timestamp}\")\n\nif __name__ == \"__main__\":\n    main()\n\"\"\"\n    \n    # Encode the content in base64\n    encoded_content = base64.b64encode(script_content.encode()).decode()\n    \n    # Data for the request\n    data = {\n        \"message\": \"Add Python script for daily updates\",\n        \"content\": encoded_content\n    }\n    \n    try:\n        # Check if file already exists\n        response = requests.get(url, headers=headers)\n        \n        if response.status_code == 200:\n            # File exists, update it\n            sha = response.json().get(\"sha\")\n            data[\"sha\"] = sha\n            print(\"Script file already exists, updating it...\")\n        else:\n            print(\"Creating new script file...\")\n        \n        # Create or update the file\n        response = requests.put(url, headers=headers, data=json.dumps(data))\n        response.raise_for_status()\n        \n        print(\"Script file created successfully!\")\n        return True\n        \n    except requests.exceptions.RequestException as e:\n        print(f\"Error creating script file: {e}\")\n        return False\n\ndef trigger_workflow(username, repo_name, token):\n    \"\"\"\n    Manually trigger the GitHub Actions workflow\n    \"\"\"\n    print(\"Triggering the workflow...\")\n    \n    # API endpoint for workflow dispatch\n    url = f\"https://api.github.com/repos/{username}/{repo_name}/actions/workflows/daily-commit.yml/dispatches\"\n    \n    # Headers with authentication\n    headers = {\n        \"Authorization\": f\"token {token}\",\n        \"Accept\": \"application/vnd.github.v3+json\"\n    }\n    \n    # Data for the request\n    data = {\n        \"ref\": \"main\"  # Use the main branch\n    }\n    \n    try:\n        # Trigger the workflow\n        response = requests.post(url, headers=headers, data=json.dumps(data))\n        \n        if response.status_code == 204:\n            print(\"Workflow triggered successfully!\")\n            return True\n        else:\n            print(f\"Error triggering workflow: {response.status_code}\")\n            print(response.text)\n            return False\n        \n    except requests.exceptions.RequestException as e:\n        print(f\"Error triggering workflow: {e}\")\n        return False\n\ndef check_workflow_status(username, repo_name, token):\n    \"\"\"\n    Check the status of the workflow run\n    \"\"\"\n    print(\"Checking workflow status...\")\n    \n    # API endpoint for workflow runs\n    url = f\"https://api.github.com/repos/{username}/{repo_name}/actions/runs\"\n    \n    # Headers with authentication\n    headers = {\n        \"Authorization\": f\"token {token}\",\n        \"Accept\": \"application/vnd.github.v3+json\"\n    }\n    \n    try:\n        # Get all workflow runs\n        response = requests.get(url, headers=headers)\n        response.raise_for_status()\n        \n        workflow_runs = response.json().get(\"workflow_runs\", [])\n        \n        if workflow_runs:\n            latest_run = workflow_runs[0]\n            run_id = latest_run.get(\"id\")\n            status = latest_run.get(\"status\")\n            conclusion = latest_run.get(\"conclusion\")\n            html_url = latest_run.get(\"html_url\")\n            \n            print(f\"Latest workflow run (ID: {run_id}):\")\n            print(f\"Status: {status}\")\n            print(f\"Conclusion: {conclusion or 'Not finished'}\")\n            print(f\"URL: {html_url}\")\n            \n            return latest_run\n        else:\n            print(\"No workflow runs found.\")\n            return None\n        \n    except requests.exceptions.RequestException as e:\n        print(f\"Error checking workflow status: {e}\")\n        return None\n\ndef main_automated_setup():\n    \"\"\"\n    Main function to automate the entire setup process\n    \"\"\"\n    # Get username and repo name\n    username = \"algsoch\"\n    repo_name = \"daily-commit-automation\"\n    \n    # Get token from environment or input\n    github_token = os.getenv(\"GITHUB_TOKEN\")\n    \n    if not github_token:\n        print(\"GitHub token is required for automated setup.\")\n        github_token = input(\"Enter your GitHub token: \")\n    \n    # Step 1: Create the repository\n    repo_url = create_github_repo(username, repo_name, github_token)\n    \n    if not repo_url:\n        print(\"Failed to create or verify repository. Exiting.\")\n        return\n    \n    # Step 2: Create the workflow file\n    if not create_workflow_file(username, repo_name, github_token):\n        print(\"Failed to create workflow file. Exiting.\")\n        return\n    \n    # Step 3: Create the Python script file\n    if not create_script_file(username, repo_name, github_token):\n        print(\"Failed to create script file. Exiting.\")\n        return\n    \n    # Step 4: Trigger the workflow\n    if not trigger_workflow(username, repo_name, github_token):\n        print(\"Failed to trigger workflow. You can trigger it manually from the GitHub UI.\")\n    else:\n        print(\"Waiting 10 seconds for the workflow to start...\")\n        time.sleep(10)\n        \n        # Step 5: Check the workflow status\n        latest_run = check_workflow_status(username, repo_name, github_token)\n        \n        if latest_run:\n            print(\"\\nWorkflow is now running. You can check its status at:\")\n            print(latest_run.get(\"html_url\"))\n    \n    print(\"\\nSetup complete!\")\n    print(f\"Repository URL: https://github.com/{username}/{repo_name}\")\n    print(\"The workflow is set to run daily at 15:45 UTC.\")\n    print(\"You can also trigger it manually from the Actions tab in your repository.\")\n\ndef update_workflow():\n    # Get username and repo name\n    username = \"algsoch\"\n    repo_name = \"daily-commit-automation\"\n    \n    # Get token from environment or input\n    github_token = os.getenv(\"GITHUB_TOKEN\")\n    \n    if not github_token:\n        print(\"GitHub token is required for automated setup.\")\n        github_token = input(\"Enter your GitHub token: \")\n    \n    # Update the workflow file\n    if create_workflow_file(username, repo_name, github_token):\n        print(\"Workflow file updated successfully!\")\n        \n        # Trigger the workflow again\n        if trigger_workflow(username, repo_name, github_token):\n            print(\"Workflow triggered successfully!\")\n            print(\"Waiting 10 seconds for the workflow to start...\")\n            time.sleep(10)\n            \n            # Check the workflow status\n            latest_run = check_workflow_status(username, repo_name, github_token)\n            \n            if latest_run:\n                print(\"\\nWorkflow is now running. You can check its status at:\")\n                print(latest_run.get(\"html_url\"))\n        else:\n            print(\"Failed to trigger workflow. You can trigger it manually from the GitHub UI.\")\n    else:\n        print(\"Failed to update workflow file.\")\n\nif __name__ == \"__main__\":\n    update_workflow()  # Only update the workflow, don't recreate the repository"
    },
    {
        "file": "E://data science tool//GA4//ninth.py",
        "question": null,
        "parameter": null,
        "code": "import os\nimport sys\nimport argparse\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport tempfile\nimport re\nimport requests\nfrom io import BytesIO\nimport signal\nimport sys\n\n# Signal handler for proper cleanup\ndef signal_handler(sig, frame):\n    print('Ctrl+C pressed, cleaning up and exiting...')\n    # Force garbage collection to release file handles\n    import gc\n    gc.collect()\n    sys.exit(0)\n\n# Register the signal handler\nsignal.signal(signal.SIGINT, signal_handler)\n\n# Define a function to check if a package is installed\ndef is_package_installed(package_name):\n    try:\n        __import__(package_name)\n        return True\n    except ImportError:\n        return False\n\n# Try to import optional packages with fallbacks\ntry:\n    import tabula\n    TABULA_AVAILABLE = True\nexcept ImportError:\n    TABULA_AVAILABLE = False\n    print(\"Warning: tabula-py not installed. Some PDF extraction features will be limited.\")\n\ntry:\n    import camelot\n    CAMELOT_AVAILABLE = True\nexcept ImportError:\n    CAMELOT_AVAILABLE = False\n    print(\"Warning: camelot-py not installed. Some PDF extraction features will be limited.\")\n\ntry:\n    from PyPDF2 import PdfReader\n    PYPDF2_AVAILABLE = True\nexcept ImportError:\n    PYPDF2_AVAILABLE = False\n    print(\"Warning: PyPDF2 not installed. Some PDF metadata features will be limited.\")\n\ndef download_pdf(url, save_path=None):\n    \"\"\"\n    Download a PDF file from a URL and save it locally if needed\n    with improved error handling\n    \"\"\"\n    print(\"Downloading PDF file...\")\n    temp_file = None\n    \n    try:\n        response = requests.get(url, stream=True)\n        if response.status_code == 200:\n            if save_path:\n                # Stream content to file to avoid memory issues with large PDFs\n                with open(save_path, 'wb') as f:\n                    for chunk in response.iter_content(chunk_size=8192):\n                        f.write(chunk)\n                print(f\"PDF saved to {save_path}\")\n                return save_path\n            else:\n                # If no save path, create a temporary file\n                temp_file = tempfile.NamedTemporaryFile(suffix='.pdf', delete=False)\n                for chunk in response.iter_content(chunk_size=8192):\n                    temp_file.write(chunk)\n                temp_file.close()\n                print(f\"PDF downloaded to temporary file: {temp_file.name}\")\n                return temp_file.name\n        else:\n            print(f\"Failed to download PDF: {response.status_code}\")\n            return None\n    except Exception as e:\n        print(f\"Error downloading PDF: {str(e)}\")\n        if temp_file and hasattr(temp_file, 'name') and os.path.exists(temp_file.name):\n            try:\n                os.unlink(temp_file.name)\n            except:\n                pass\n        return None\n\ndef extract_tables(pdf_path):\n    \"\"\"\n    Extract tables from PDF using available libraries with better temp file handling\n    \"\"\"\n    tables = []\n    temp_dir = None\n    \n    if TABULA_AVAILABLE:\n        print(\"Extracting tables using tabula-py...\")\n        try:\n            # Extract all tables from all pages\n            tabula_tables = tabula.read_pdf(pdf_path, pages='all', multiple_tables=True)\n            print(f\"Extracted {len(tabula_tables)} tables using tabula\")\n            tables.extend(tabula_tables)\n        except Exception as e:\n            print(f\"Error extracting tables with tabula: {e}\")\n    \n    if CAMELOT_AVAILABLE:\n        print(\"Extracting tables using camelot...\")\n        try:\n            # Create a custom temp directory for camelot\n            temp_dir = tempfile.mkdtemp(prefix=\"camelot_\")\n            os.environ[\"TMPDIR\"] = temp_dir\n            \n            # Extract tables with camelot - limit to first 50 pages to avoid memory issues\n            try:\n                # First try with limited pages\n                camelot_tables = camelot.read_pdf(pdf_path, pages='1-50')\n                print(f\"Extracted {len(camelot_tables)} tables from first 50 pages using camelot\")\n                tables.extend([table.df for table in camelot_tables])\n                \n                # If PDF has more than 50 pages, process the rest in batches\n                if PYPDF2_AVAILABLE:\n                    with open(pdf_path, 'rb') as f:\n                        reader = PdfReader(f)\n                        num_pages = len(reader.pages)\n                        \n                        if num_pages > 50:\n                            # Process remaining pages in batches of 50\n                            for start_page in range(51, num_pages+1, 50):\n                                end_page = min(start_page + 49, num_pages)\n                                page_range = f\"{start_page}-{end_page}\"\n                                print(f\"Processing pages {page_range}...\")\n                                \n                                try:\n                                    batch_tables = camelot.read_pdf(pdf_path, pages=page_range)\n                                    print(f\"Extracted {len(batch_tables)} tables from pages {page_range}\")\n                                    tables.extend([table.df for table in batch_tables])\n                                except Exception as batch_error:\n                                    print(f\"Error processing batch {page_range}: {batch_error}\")\n            except Exception as batch_error:\n                # If batched approach fails, try with all pages\n                print(f\"Batch processing failed: {batch_error}\")\n                print(\"Trying with all pages at once...\")\n                camelot_tables = camelot.read_pdf(pdf_path, pages='all')\n                print(f\"Extracted {len(camelot_tables)} tables using camelot\")\n                tables.extend([table.df for table in camelot_tables])\n                \n        except Exception as e:\n            print(f\"Error extracting tables with camelot: {e}\")\n        finally:\n            # Close any open file handles by resetting environment\n            os.environ.pop(\"TMPDIR\", None)\n            \n            # Schedule cleanup for the end of program\n            if temp_dir:\n                import atexit\n                atexit.register(lambda: safe_cleanup(temp_dir))\n    \n    return tables\n\ndef get_pdf_metadata(pdf_path):\n    \"\"\"\n    Extract basic metadata from PDF file\n    \"\"\"\n    if PYPDF2_AVAILABLE:\n        try:\n            with open(pdf_path, 'rb') as file:\n                reader = PdfReader(file)\n                num_pages = len(reader.pages)\n                return {'num_pages': num_pages}\n        except Exception as e:\n            print(f\"Error extracting PDF metadata: {e}\")\n    \n    return {'num_pages': 0}\n\ndef combine_tables(tables):\n    \"\"\"\n    Combine multiple tables into a single DataFrame\n    \"\"\"\n    if not tables:\n        return pd.DataFrame()\n    \n    combined_df = pd.DataFrame()\n    \n    for table in tables:\n        # Skip empty tables\n        if table.empty:\n            continue\n        \n        # Check if this table has enough columns for our analysis\n        if table.shape[1] >= 5:  # Assuming at least 5 columns (ID, Group, Maths, Physics, etc.)\n            # If combined_df is empty, use this table as the base\n            if combined_df.empty:\n                combined_df = table.copy()\n            else:\n                # Append this table to the combined_df\n                combined_df = pd.concat([combined_df, table], ignore_index=True)\n    \n    return combined_df\n\ndef clean_and_prepare_data(df):\n    \"\"\"\n    Clean and prepare the data for analysis with group detection from headers\n    \"\"\"\n    print(\"Cleaning and preparing data...\")\n    \n    # Make a copy to avoid modifying the original\n    cleaned_df = df.copy()\n    \n    # First, try to extract group information from column headers\n    group_info = None\n    for col in cleaned_df.columns:\n        col_str = str(col).lower()\n        # Look for patterns like \"group X\" or \"group-X\" in column headers\n        if 'group' in col_str:\n            group_match = re.search(r'group[\\s-]*(\\d+)', col_str)\n            if group_match:\n                group_info = int(group_match.group(1))\n                print(f\"Detected Group {group_info} from column header: {col}\")\n                break\n    \n    # If the first row contains headers, set it as the header\n    if not all(col.strip().isdigit() for col in cleaned_df.iloc[0].astype(str) if col.strip()):\n        cleaned_df.columns = cleaned_df.iloc[0]\n        cleaned_df = cleaned_df.iloc[1:].reset_index(drop=True)\n    \n    # Try to identify columns based on expected content\n    column_mapping = {}\n    for col in cleaned_df.columns:\n        col_str = str(col).lower()\n        if 'student' in col_str or 'id' in col_str or 'roll' in col_str:\n            column_mapping[col] = 'Student_ID'\n        elif 'math' in col_str:\n            column_mapping[col] = 'Maths'\n        elif 'phy' in col_str:\n            column_mapping[col] = 'Physics'\n        elif 'eng' in col_str:\n            column_mapping[col] = 'English'\n        elif 'eco' in col_str:\n            column_mapping[col] = 'Economics'\n        elif 'bio' in col_str:\n            column_mapping[col] = 'Biology'\n        elif 'group' in col_str and 'Group' not in column_mapping.values():\n            column_mapping[col] = 'Group'\n    \n    # If we found mappings, rename columns\n    if column_mapping:\n        cleaned_df = cleaned_df.rename(columns=column_mapping)\n    \n    # If columns still don't have proper names, assign default ones\n    if not any(col in ['Maths', 'Physics', 'English', 'Economics', 'Biology'] for col in cleaned_df.columns):\n        if len(cleaned_df.columns) >= 7:  # Assuming ID, Group, and 5 subjects\n            cleaned_df.columns = ['Student_ID', 'Group', 'Maths', 'Physics', 'English', 'Economics', 'Biology']\n        elif len(cleaned_df.columns) >= 6:\n            cleaned_df.columns = ['Student_ID', 'Group', 'Maths', 'Physics', 'English', 'Economics']\n        elif len(cleaned_df.columns) >= 5:\n            cleaned_df.columns = ['Student_ID', 'Group', 'Maths', 'Physics', 'English']\n    \n    # Convert marks columns to numeric\n    subject_columns = ['Maths', 'Physics', 'English', 'Economics', 'Biology']\n    for col in subject_columns:\n        if col in cleaned_df.columns:\n            cleaned_df[col] = pd.to_numeric(cleaned_df[col], errors='coerce')\n    \n    # Add Group column if it doesn't exist but we found group info in headers\n    if 'Group' not in cleaned_df.columns and group_info is not None:\n        cleaned_df['Group'] = group_info\n        print(f\"Added Group column with value {group_info} based on header information\")\n    \n    # Convert Group column to numeric if it exists\n    if 'Group' in cleaned_df.columns:\n        # Extract numeric part from group values (e.g., \"Group 5\" -> 5)\n        cleaned_df['Group'] = cleaned_df['Group'].astype(str).str.extract(r'(\\d+)').astype(float)\n    \n    # Drop rows with all NaN values\n    cleaned_df = cleaned_df.dropna(how='all')\n    \n    return cleaned_df\n\ndef analyze_student_data(df):\n    \"\"\"\n    Analyze the student data to calculate total Physics marks\n    of students who scored 69 or more in Maths in groups 1-25\n    \"\"\"\n    print(\"Analyzing student data...\")\n    \n    # Ensure required columns exist\n    required_columns = ['Maths', 'Physics', 'Group']\n    missing_columns = [col for col in required_columns if col not in df.columns]\n    \n    if missing_columns:\n        print(f\"Missing required columns: {missing_columns}\")\n        return None\n    \n    # Filter students who scored 69 or more in Maths\n    high_math_scorers = df[df['Maths'] >= 69]\n    \n    # Further filter to include only groups 1-25\n    target_students = high_math_scorers[(high_math_scorers['Group'] >= 1) & (high_math_scorers['Group'] <= 25)]\n    \n    # Calculate total Physics marks\n    total_physics_marks = target_students['Physics'].sum()\n    \n    # Get more insights\n    count_students = len(target_students)\n    avg_physics_marks = target_students['Physics'].mean() if count_students > 0 else 0\n    \n    print(f\"Number of students who scored 69+ in Maths in groups 1-25: {count_students}\")\n    print(f\"Average Physics marks of these students: {avg_physics_marks:.2f}\")\n    print(f\"Total Physics marks of these students: {total_physics_marks:.2f}\")\n    \n    return {\n        'total_physics_marks': total_physics_marks,\n        'count_students': count_students,\n        'avg_physics_marks': avg_physics_marks,\n        'filtered_data': target_students\n    }\n\ndef visualize_results(analysis_result, output_path='student_analysis.png'):\n    \"\"\"\n    Create visualizations of the analysis results\n    \"\"\"\n    if not analysis_result:\n        print(\"No analysis results to visualize\")\n        return\n    \n    filtered_data = analysis_result['filtered_data']\n    \n    if filtered_data.empty:\n        print(\"No data to visualize after filtering\")\n        return\n    \n    plt.figure(figsize=(15, 10))\n    \n    # Plot 1: Maths vs Physics scores for filtered students\n    plt.subplot(2, 2, 1)\n    plt.scatter(filtered_data['Maths'], filtered_data['Physics'])\n    plt.xlabel('Maths Marks')\n    plt.ylabel('Physics Marks')\n    plt.title('Maths vs Physics Marks for Students with Maths \u2265 69 in Groups 1-25')\n    \n    # Plot 2: Distribution of Physics marks\n    plt.subplot(2, 2, 2)\n    plt.hist(filtered_data['Physics'], bins=10, alpha=0.7)\n    plt.xlabel('Physics Marks')\n    plt.ylabel('Number of Students')\n    plt.title('Distribution of Physics Marks')\n    \n    # Plot 3: Group-wise average Physics marks\n    try:\n        group_avg = filtered_data.groupby('Group')['Physics'].mean().reset_index()\n        plt.subplot(2, 2, 3)\n        plt.bar(group_avg['Group'], group_avg['Physics'])\n        plt.xlabel('Group')\n        plt.ylabel('Average Physics Marks')\n        plt.title('Average Physics Marks by Group')\n    except Exception as e:\n        print(f\"Error creating group average plot: {e}\")\n        plt.subplot(2, 2, 3)\n        plt.text(0.5, 0.5, \"Error creating group plot\", ha='center', va='center')\n    \n    # Plot 4: Summary statistics\n    plt.subplot(2, 2, 4)\n    plt.axis('off')\n    summary_text = f\"\"\"\n    Summary Statistics:\n    \n    Total students: {analysis_result['count_students']}\n    Average Physics marks: {analysis_result['avg_physics_marks']:.2f}\n    Total Physics marks: {analysis_result['total_physics_marks']:.2f}\n    \n    Criteria:\n    - Maths marks \u2265 69\n    - Groups 1-25\n    \"\"\"\n    plt.text(0.1, 0.5, summary_text, fontsize=12)\n    \n    plt.tight_layout()\n    try:\n        plt.savefig(output_path)\n        print(f\"Visualization saved to {output_path}\")\n    except Exception as e:\n        print(f\"Error saving visualization: {e}\")\n    \n    return output_path\n\ndef create_sample_data():\n    \"\"\"\n    Create sample data for testing when no PDF is provided\n    \"\"\"\n    print(\"Creating sample data for demonstration...\")\n    np.random.seed(42)  # For reproducible results\n    \n    data = {\n        'Student_ID': range(1, 101),\n        'Group': [i//4 + 1 for i in range(100)],  # Groups 1-25\n        'Maths': np.random.randint(50, 100, 100),\n        'Physics': np.random.randint(50, 100, 100),\n        'English': np.random.randint(50, 100, 100),\n        'Economics': np.random.randint(50, 100, 100),\n        'Biology': np.random.randint(50, 100, 100)\n    }\n    return pd.DataFrame(data)\n\ndef process_multiple_tables(tables):\n    \"\"\"\n    Process multiple tables where each table might represent a different group\n    \"\"\"\n    all_data = []\n    \n    for i, table in enumerate(tables):\n        if table.empty:\n            continue\n        \n        print(f\"Processing table {i+1}/{len(tables)}\")\n        \n        # Look for group information in the table\n        group_info = None\n        \n        # Check column headers for group info\n        for col in table.columns:\n            col_str = str(col).lower()\n            if 'group' in col_str:\n                group_match = re.search(r'group[\\s-]*(\\d+)', col_str)\n                if group_match:\n                    group_info = int(group_match.group(1))\n                    print(f\"  - Found Group {group_info} in table {i+1} header\")\n                    break\n        \n        # If no group in headers, check first few rows\n        if group_info is None:\n            for r in range(min(3, len(table))):\n                for c in range(len(table.columns)):\n                    cell_value = str(table.iloc[r, c]).lower()\n                    if 'group' in cell_value:\n                        group_match = re.search(r'group[\\s-]*(\\d+)', cell_value)\n                        if group_match:\n                            group_info = int(group_match.group(1))\n                            print(f\"  - Found Group {group_info} in table {i+1} cell data\")\n                            break\n                if group_info is not None:\n                    break\n        \n        # Clean and prepare the table\n        cleaned_table = clean_and_prepare_data(table)\n        \n        # If we found group info but there's no Group column, add it\n        if group_info is not None and 'Group' not in cleaned_table.columns:\n            cleaned_table['Group'] = group_info\n            print(f\"  - Added Group column with value {group_info}\")\n        \n        # Only add tables with useful data\n        if not cleaned_table.empty and 'Maths' in cleaned_table.columns and 'Physics' in cleaned_table.columns:\n            all_data.append(cleaned_table)\n        else:\n            print(f\"  - Table {i+1} skipped (missing required columns)\")\n    \n    # Combine all tables into one DataFrame\n    if not all_data:\n        print(\"No useful data found in any table\")\n        return pd.DataFrame()\n    \n    combined_df = pd.concat(all_data, ignore_index=True)\n    print(f\"Combined {len(all_data)} tables with a total of {len(combined_df)} rows\")\n    \n    return combined_df\n\ndef analyze_pdf_structure(pdf_path):\n    \"\"\"\n    Analyze the structure of the PDF to understand tables and group organization\n    \"\"\"\n    print(\"\\n=== PDF STRUCTURE ANALYSIS ===\")\n    structure_info = {\n        'groups_detected': [],\n        'table_structure': None,\n        'pages_per_group': 1,\n        'rows_per_group': 30  # Default assumption\n    }\n    \n    # First, use PyPDF2 to extract text and look for patterns\n    if PYPDF2_AVAILABLE:\n        try:\n            with open(pdf_path, 'rb') as file:\n                reader = PdfReader(file)\n                num_pages = len(reader.pages)\n                print(f\"Total pages in PDF: {num_pages}\")\n                \n                # Analyze a sample of pages to detect patterns\n                sample_pages = min(10, num_pages)\n                group_pattern = re.compile(r'group[\\s-]*(\\d+)', re.IGNORECASE)\n                \n                for i in range(sample_pages):\n                    page_text = reader.pages[i].extract_text()\n                    \n                    # Look for group indicators\n                    group_matches = group_pattern.findall(page_text)\n                    if group_matches:\n                        detected_group = int(group_matches[0])\n                        print(f\"Page {i+1}: Detected Group {detected_group}\")\n                        if detected_group not in structure_info['groups_detected']:\n                            structure_info['groups_detected'].append(detected_group)\n                \n                # Estimate the number of pages per group\n                if len(structure_info['groups_detected']) > 1:\n                    # If we detected more than one group in our sample, estimate pages per group\n                    structure_info['pages_per_group'] = sample_pages // len(structure_info['groups_detected'])\n                    print(f\"Estimated {structure_info['pages_per_group']} pages per group\")\n                \n                print(f\"Groups detected in sample: {structure_info['groups_detected']}\")\n        except Exception as e:\n            print(f\"Error analyzing PDF with PyPDF2: {e}\")\n    \n    # Try extracting a sample table to understand structure\n    if CAMELOT_AVAILABLE:\n        try:\n            # Just extract tables from the first page for structure analysis\n            tables = camelot.read_pdf(pdf_path, pages='1')\n            if tables:\n                sample_table = tables[0].df\n                rows, cols = sample_table.shape\n                print(f\"Sample table structure: {rows} rows x {cols} columns\")\n                \n                # Store the sample table for column analysis\n                structure_info['table_structure'] = sample_table\n                \n                # Analyze column headers\n                print(\"Column headers in sample table:\")\n                for col in sample_table.columns:\n                    print(f\"  - {col}\")\n                \n                # Analyze first row to see if it contains headers\n                if rows > 0:\n                    print(\"First row values:\")\n                    for idx, val in enumerate(sample_table.iloc[0]):\n                        print(f\"  - Column {idx}: {val}\")\n                \n                # Estimate rows per group based on table size\n                if rows > 5:  # If table has reasonable size\n                    structure_info['rows_per_group'] = rows\n                    print(f\"Setting rows per group to {rows} based on sample table\")\n        except Exception as e:\n            print(f\"Error analyzing table structure with Camelot: {e}\")\n    \n    # If we didn't detect any groups, but have page count, make an estimate\n    if not structure_info['groups_detected'] and 'num_pages' in locals():\n        # Estimate number of groups based on page count\n        estimated_groups = num_pages // structure_info['pages_per_group']\n        print(f\"Estimated total number of groups: {estimated_groups}\")\n    \n    print(\"=== END OF STRUCTURE ANALYSIS ===\\n\")\n    return structure_info\n\ndef assign_groups_based_on_structure(tables, structure_info):\n    \"\"\"\n    Assign groups to tables based on the PDF structure analysis\n    \"\"\"\n    all_data = []\n    page_to_group_map = {}\n    \n    # Determine how groups are mapped to pages/tables\n    if structure_info['groups_detected']:\n        # If we detected specific groups in specific pages, use that info\n        for i, group in enumerate(structure_info['groups_detected']):\n            start_page = i * structure_info['pages_per_group'] + 1\n            end_page = start_page + structure_info['pages_per_group'] - 1\n            for page in range(start_page, end_page + 1):\n                page_to_group_map[page] = group\n        \n        # Fill in missing pages with sequential groups\n        max_detected = max(structure_info['groups_detected']) if structure_info['groups_detected'] else 0\n        next_group = max_detected + 1\n    else:\n        # If we didn't detect specific groups, assign sequentially\n        next_group = 1\n    \n    # Process each table with group information\n    current_page = 1\n    for i, table in enumerate(tables):\n        if table.empty:\n            continue\n        \n        print(f\"Processing table {i+1}/{len(tables)}\")\n        \n        # Try to determine which page this table is from (camelot specific)\n        table_page = getattr(table, 'page', current_page) if hasattr(table, 'page') else current_page\n        \n        # Get group number from page map or assign next available\n        if table_page in page_to_group_map:\n            group_number = page_to_group_map[table_page]\n        else:\n            group_number = next_group\n            page_to_group_map[table_page] = group_number\n            next_group += 1\n        \n        # Clean and prepare the table data\n        table_df = table.df if hasattr(table, 'df') else table\n        cleaned_table = clean_and_prepare_data(table_df)\n        \n        # Add group information\n        if 'Group' not in cleaned_table.columns:\n            cleaned_table['Group'] = group_number\n            print(f\"  - Assigned Group {group_number} to table {i+1}\")\n        \n        # Add to our data collection if it has the required columns\n        if not cleaned_table.empty and 'Maths' in cleaned_table.columns and 'Physics' in cleaned_table.columns:\n            all_data.append(cleaned_table)\n        else:\n            print(f\"  - Table {i+1} skipped (missing required columns)\")\n        \n        # Update current page\n        current_page = table_page + 1\n    \n    # Combine all tables into one DataFrame\n    if not all_data:\n        print(\"No useful data found in any table\")\n        return pd.DataFrame()\n    \n    combined_df = pd.concat(all_data, ignore_index=True)\n    print(f\"Combined {len(all_data)} tables with a total of {len(combined_df)} rows\")\n    \n    return combined_df\n\ndef assign_groups_by_header_repetition(tables):\n    \"\"\"\n    Assign groups to tables based on repeating header patterns.\n    When the same column headers appear again, it indicates a new group.\n    \"\"\"\n    all_data = []\n    current_group = 1\n    previous_headers = None\n    \n    print(\"Assigning groups based on repeating header patterns...\")\n    \n    for i, table in enumerate(tables):\n        if table.empty:\n            continue\n        \n        print(f\"Processing table {i+1}/{len(tables)}\")\n        \n        # Get column headers as a string for comparison\n        table_df = table.df if hasattr(table, 'df') else table\n        current_headers = str(table_df.columns.tolist())\n        \n        # If this is the first table, use as reference headers\n        if previous_headers is None:\n            previous_headers = current_headers\n        # If headers repeat, increment group number\n        elif current_headers == previous_headers:\n            current_group += 1\n            print(f\"  - Detected repeating headers - starting Group {current_group}\")\n        \n        # Clean and prepare the table\n        cleaned_table = clean_and_prepare_data(table_df)\n        \n        # Add group column\n        if 'Group' not in cleaned_table.columns:\n            cleaned_table['Group'] = current_group\n            print(f\"  - Assigned Group {current_group} to table {i+1}\")\n        \n        # Only add tables with useful data\n        if not cleaned_table.empty and 'Maths' in cleaned_table.columns and 'Physics' in cleaned_table.columns:\n            all_data.append(cleaned_table)\n        else:\n            print(f\"  - Table {i+1} skipped (missing required columns)\")\n        \n        # Update previous headers for next comparison\n        previous_headers = current_headers\n    \n    # Combine all tables into one DataFrame\n    if not all_data:\n        print(\"No useful data found in any table\")\n        return pd.DataFrame()\n    \n    combined_df = pd.concat(all_data, ignore_index=True)\n    print(f\"Combined {len(all_data)} tables with a total of {len(combined_df)} rows across {current_group} groups\")\n    \n    return combined_df\n\ndef ensure_group_column(df, structure_info=None):\n    \"\"\"\n    Make sure the dataframe has a Group column using various fallback strategies\n    \"\"\"\n    if 'Group' in df.columns:\n        return df\n    \n    print(\"Group column missing - trying alternative assignment methods\")\n    result_df = df.copy()\n    \n    # Method 1: Try to extract group from a page number column if it exists\n    if 'Page' in result_df.columns:\n        result_df['Group'] = result_df['Page'].apply(lambda x: int(x) if pd.notnull(x) else 0)\n        print(\"Assigned groups based on Page column\")\n        return result_df\n    \n    # Method 2: If we have structure info with rows_per_group, use that\n    if structure_info and 'rows_per_group' in structure_info:\n        rows_per_group = structure_info['rows_per_group']\n        result_df['Group'] = (np.arange(len(result_df)) // rows_per_group) + 1\n        print(f\"Assigned groups based on structure analysis ({rows_per_group} rows per group)\")\n        return result_df\n    \n    # Method 3: Default assignment - 30 students per group\n    result_df['Group'] = (np.arange(len(result_df)) // 30) + 1\n    print(\"Assigned default groups (30 students per group)\")\n    \n    return result_df\n\ndef safe_cleanup(temp_dir):\n    \"\"\"Safely clean up temporary files to avoid permission errors\"\"\"\n    import time\n    \n    # Wait a moment to let any file operations complete\n    time.sleep(1)\n    \n    try:\n        # Try to remove the directory\n        if os.path.exists(temp_dir):\n            import shutil\n            shutil.rmtree(temp_dir, ignore_errors=True)\n            print(f\"Cleaned up temporary files in {temp_dir}\")\n    except Exception as e:\n        print(f\"Note: Could not clean up some temporary files: {e}\")\n        print(\"This is not a critical error and doesn't affect results.\")\n\ndef main():\n    # Set up argument parser with YOUR CORRECT default PDF file\n    parser = argparse.ArgumentParser(description=\"Extract and analyze student marks from PDF\")\n    parser.add_argument(\"--file\", \"-f\", \n                      default=\"E:\\\\data science tool\\\\GA4\\\\q-extract-tables-from-pdf.pdf\",\n                      help=\"Path to PDF file containing student marks\")\n    parser.add_argument(\"--url\", \"-u\", help=\"URL to PDF file containing student marks\")\n    parser.add_argument(\"--output\", \"-o\", default=\"student_analysis.png\", help=\"Output path for visualization\")\n    parser.add_argument(\"--csv\", \"-c\", help=\"Output path for CSV data (optional)\")\n    parser.add_argument(\"--sample\", \"-s\", action=\"store_true\", help=\"Use sample data instead of PDF\")\n    parser.add_argument(\"--no-viz\", action=\"store_true\", help=\"Skip visualization generation\")\n    \n    # Parse arguments\n    args = parser.parse_args()\n    \n    # Print startup message\n    print(f\"PDF Analysis Tool - Starting with file: {args.file}\")\n    \n    # Check dependencies\n    if not TABULA_AVAILABLE and not CAMELOT_AVAILABLE and not args.sample:\n        print(\"Warning: Neither tabula-py nor camelot-py is installed. Cannot extract tables from PDF.\")\n        print(\"Please install at least one of these packages or use --sample for demo data.\")\n        print(\"Try: pip install tabula-py\")\n        if not args.sample:\n            print(\"Switching to sample data mode...\")\n            args.sample = True\n    \n    # Determine data source\n    if args.sample:\n        print(\"Using sample data\")\n        combined_df = create_sample_data()\n    elif args.url:\n        # Download PDF from URL\n        with tempfile.NamedTemporaryFile(suffix='.pdf', delete=False) as temp_file:\n            pdf_path = download_pdf(args.url, temp_file.name)\n            if not pdf_path:\n                print(\"Error downloading PDF from URL. Using sample data instead.\")\n                combined_df = create_sample_data()\n            else:\n                # Extract tables from the PDF\n                tables = extract_tables(pdf_path)\n                combined_df = combine_tables(tables)\n                \n                # Clean up temp file\n                os.unlink(pdf_path)\n    else:\n        # Check if the PDF exists\n        if not os.path.exists(args.file):\n            print(f\"PDF file not found: {args.file}\")\n            \n            # Try looking in common locations\n            possible_locations = [\n                args.file,\n                os.path.join(os.getcwd(), args.file),\n                os.path.join(os.getcwd(), \"PDFs\", args.file),\n                os.path.join(os.getcwd(), \"data\", args.file),\n                os.path.join(\"E:\\\\data science tool\\\\GA4\", args.file)\n            ]\n            \n            found_file = False\n            for location in possible_locations:\n                if os.path.exists(location):\n                    print(f\"Found PDF at: {location}\")\n                    args.file = location\n                    found_file = True\n                    break\n            \n            if not found_file:\n                print(\"Using sample data instead\")\n                combined_df = create_sample_data()\n                args.sample = True\n        \n        if not args.sample:\n            # Extract tables from the PDF\n            print(f\"Extracting tables from {args.file}\")\n            metadata = get_pdf_metadata(args.file)\n            print(f\"PDF has {metadata.get('num_pages', 'unknown')} pages\")\n            \n            # First analyze the structure of the PDF\n            structure_info = analyze_pdf_structure(args.file)\n            \n            # Extract tables\n            tables = extract_tables(args.file)\n            \n            if not tables:\n                print(\"No tables extracted from PDF. Using sample data instead.\")\n                combined_df = create_sample_data()\n                args.sample = True\n            else:\n                # Try different group assignment methods in order of preference\n                methods = [\n                    (\"header repetition\", lambda: assign_groups_by_header_repetition(tables)),\n                    (\"structure-based\", lambda: assign_groups_based_on_structure(tables, structure_info)),\n                    (\"table processing\", lambda: process_multiple_tables(tables))\n                ]\n                \n                combined_df = pd.DataFrame()\n                for method_name, method_func in methods:\n                    print(f\"\\nTrying group assignment using {method_name} approach...\")\n                    try:\n                        result_df = method_func()\n                        if not result_df.empty and 'Group' in result_df.columns:\n                            combined_df = result_df\n                            print(f\"Successfully assigned groups using {method_name} approach!\")\n                            break\n                        else:\n                            print(f\"The {method_name} approach did not produce valid results.\")\n                    except Exception as e:\n                        print(f\"Error with {method_name} approach: {e}\")\n                \n                # If all methods failed, use basic table combination\n                if combined_df.empty:\n                    print(\"\\nAll group assignment methods failed. Using basic table combination...\")\n                    combined_df = combine_tables(tables)\n    \n    # Clean and prepare the data\n    cleaned_df = clean_and_prepare_data(combined_df)\n    \n    # Ensure we have a Group column before analysis\n    if 'Group' not in cleaned_df.columns:\n        cleaned_df = ensure_group_column(cleaned_df, structure_info if not args.sample else None)\n\n    # Print sample of the data for verification\n    print(\"\\nSample of the cleaned data:\")\n    print(cleaned_df.head())\n    \n    # Analyze the data to answer the question\n    analysis_result = analyze_student_data(cleaned_df)\n    \n    # Create visualizations unless --no-viz flag is set\n    if analysis_result and not args.no_viz:\n        visualize_results(analysis_result, args.output)\n    \n    # Determine CSV output paths\n    if args.csv:\n        # User specified a custom CSV path\n        csv_base = args.csv.rsplit('.', 1)[0]\n        full_data_csv = f\"{csv_base}.csv\"\n        filtered_data_csv = f\"{csv_base}_filtered.csv\"\n    else:\n        # Use default names based on the output filename\n        csv_base = args.output.rsplit('.', 1)[0]\n        full_data_csv = f\"{csv_base}_all_data.csv\"\n        filtered_data_csv = f\"{csv_base}_filtered_data.csv\"\n    \n    # Save the full dataset to CSV\n    cleaned_df.to_csv(full_data_csv, index=False)\n    print(f\"Saved complete extracted data to: {full_data_csv}\")\n    \n    # Save the filtered dataset to CSV if analysis was successful\n    if analysis_result:\n        analysis_result['filtered_data'].to_csv(filtered_data_csv, index=False)\n        print(f\"Saved filtered data to: {filtered_data_csv}\")\n    \n    # Print the final answer\n    if analysis_result:\n        print(\"\\n\" + \"=\"*50)\n        print(f\"ANSWER: The total Physics marks of students who scored 69 or more marks\")\n        print(f\"        in Maths in groups 1-25 is {analysis_result['total_physics_marks']:.2f}\")\n        print(\"=\"*50)\n        \n        # Print additional statistics\n        print(f\"\\nNumber of students in this group: {analysis_result['count_students']}\")\n        print(f\"Average Physics marks: {analysis_result['avg_physics_marks']:.2f}\")\n        \n        # Data source information\n        source_type = \"sample data\" if args.sample else f\"PDF file: {args.file}\" if not args.url else f\"URL: {args.url}\"\n        print(f\"\\nAnalysis based on: {source_type}\")\n        \n        # Output files summary\n        print(\"\\nOutput files:\")\n        if not args.no_viz:\n            print(f\"- Visualization: {args.output}\")\n        print(f\"- Complete data: {full_data_csv}\")\n        print(f\"- Filtered data: {filtered_data_csv}\")\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
        "file": "E://data science tool//GA4//tenth.py",
        "question": null,
        "parameter": null,
        "code": "import os\nimport sys\nimport argparse\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport tempfile\nimport re\nimport requests\nfrom io import BytesIO\nimport signal\nimport subprocess\nimport shutil\nfrom pathlib import Path\n\n# Signal handler for proper cleanup\ndef signal_handler(sig, frame):\n    print('Ctrl+C pressed, cleaning up and exiting...')\n    # Force garbage collection to release file handles\n    import gc\n    gc.collect()\n    sys.exit(0)\n\n# Register the signal handler\nsignal.signal(signal.SIGINT, signal_handler)\n\ndef is_package_installed(package_name):\n    \"\"\"Check if a Python package is installed\"\"\"\n    try:\n        __import__(package_name)\n        return True\n    except ImportError:\n        return False\n\n# Try to import optional packages with fallbacks\ntry:\n    import pypandoc\n    PANDOC_AVAILABLE = True\nexcept ImportError:\n    PANDOC_AVAILABLE = False\n    print(\"Warning: pypandoc not installed. Install it for better Markdown conversion.\")\n\ntry:\n    from PyPDF2 import PdfReader\n    PYPDF2_AVAILABLE = True\nexcept ImportError:\n    PYPDF2_AVAILABLE = False\n    print(\"Warning: PyPDF2 not installed. Install it for better PDF text extraction.\")\n\ndef safe_cleanup(temp_dir):\n    \"\"\"Safely clean up temporary files to avoid permission errors\"\"\"\n    import time\n    import gc\n    \n    # Force garbage collection to release file handles\n    gc.collect()\n    \n    # Wait a moment to let any file operations complete\n    time.sleep(2)\n    \n    try:\n        # Try to remove the directory\n        if os.path.exists(temp_dir):\n            import shutil\n            # Use the ignore_errors parameter to skip over locked files\n            shutil.rmtree(temp_dir, ignore_errors=True)\n            print(f\"Cleaned up temporary files in {temp_dir}\")\n    except Exception as e:\n        print(f\"Note: Could not clean up some temporary files: {e}\")\n        print(\"This is not a critical error and doesn't affect results.\")\n\ndef check_prettier_installation():\n    \"\"\"Check if Prettier is installed and available\"\"\"\n    try:\n        # Try to run prettier --version\n        result = subprocess.run(\n            ['npx', 'prettier', '--version'], \n            capture_output=True, \n            text=True,\n            check=False\n        )\n        \n        if result.returncode == 0:\n            version = result.stdout.strip()\n            print(f\"Prettier version {version} found\")\n            return True\n        else:\n            print(\"Prettier not found or not working properly\")\n            print(f\"Error: {result.stderr}\")\n            return False\n    except Exception as e:\n        print(f\"Error checking Prettier installation: {e}\")\n        return False\n\ndef install_prettier():\n    \"\"\"Install Prettier using npm\"\"\"\n    try:\n        print(\"Installing Prettier version 3.4.2...\")\n        subprocess.run(\n            ['npm', 'install', '--save-dev', 'prettier@3.4.2'],\n            check=True\n        )\n        print(\"Prettier installed successfully\")\n        return True\n    except Exception as e:\n        print(f\"Error installing Prettier: {e}\")\n        print(\"You may need to install Node.js and npm first\")\n        return False\n\ndef extract_text_from_pdf(pdf_path):\n    \"\"\"Extract text content from a PDF file\"\"\"\n    if not PYPDF2_AVAILABLE:\n        print(\"PyPDF2 is not installed. Cannot extract text from PDF.\")\n        return None\n    \n    try:\n        text_content = []\n        with open(pdf_path, 'rb') as file:\n            reader = PdfReader(file)\n            num_pages = len(reader.pages)\n            print(f\"Extracting text from {num_pages} pages...\")\n            \n            for i in range(num_pages):\n                page = reader.pages[i]\n                text = page.extract_text()\n                text_content.append(text)\n                \n                if i % 10 == 0 and i > 0:\n                    print(f\"Processed {i}/{num_pages} pages\")\n        \n        return \"\\n\\n\".join(text_content)\n    except Exception as e:\n        print(f\"Error extracting text from PDF: {e}\")\n        return None\n\ndef pdf_to_markdown_with_pandoc(pdf_path, output_path=None):\n    \"\"\"Convert PDF to Markdown using Pandoc\"\"\"\n    if not PANDOC_AVAILABLE:\n        print(\"pypandoc is not installed. Cannot convert PDF to Markdown using Pandoc.\")\n        return None\n    \n    if output_path is None:\n        output_path = os.path.splitext(pdf_path)[0] + '.md'\n    \n    try:\n        print(f\"Converting {pdf_path} to Markdown using Pandoc...\")\n        # Use pypandoc to convert PDF to Markdown\n        output = pypandoc.convert_file(pdf_path, 'markdown', outputfile=output_path)\n        print(f\"Conversion complete. Markdown saved to {output_path}\")\n        return output_path\n    except Exception as e:\n        print(f\"Error converting PDF to Markdown with Pandoc: {e}\")\n        return None\n\ndef pdf_to_markdown_with_pdfminer(pdf_path, output_path=None):\n    \"\"\"Convert PDF to Markdown using PDFMiner\"\"\"\n    try:\n        # Try to import pdfminer.six\n        from pdfminer.high_level import extract_text as pdfminer_extract_text\n        \n        if output_path is None:\n            output_path = os.path.splitext(pdf_path)[0] + '.md'\n        \n        print(f\"Converting {pdf_path} to Markdown using PDFMiner...\")\n        text = pdfminer_extract_text(pdf_path)\n        \n        # Basic text to markdown conversion\n        markdown_text = text\n        \n        # Save the markdown\n        with open(output_path, 'w', encoding='utf-8') as f:\n            f.write(markdown_text)\n            \n        print(f\"Conversion complete. Markdown saved to {output_path}\")\n        return output_path\n    except ImportError:\n        print(\"pdfminer.six is not installed. Cannot use this conversion method.\")\n        return None\n    except Exception as e:\n        print(f\"Error converting PDF to Markdown with PDFMiner: {e}\")\n        return None\n\ndef pdf_to_markdown_basic(pdf_path, output_path=None):\n    \"\"\"Basic PDF to Markdown conversion using PyPDF2\"\"\"\n    if output_path is None:\n        output_path = os.path.splitext(pdf_path)[0] + '.md'\n    \n    text = extract_text_from_pdf(pdf_path)\n    if text is None:\n        return None\n    \n    # Basic text to markdown conversion\n    lines = text.split('\\n')\n    markdown_lines = []\n    \n    for line in lines:\n        # Strip trailing spaces\n        line = line.rstrip()\n        \n        # Skip empty lines\n        if not line.strip():\n            markdown_lines.append('')\n            continue\n        \n        # Try to detect headings based on formatting\n        if line.strip().isupper() and len(line.strip()) < 100:\n            # Likely a heading - make it a markdown heading\n            markdown_lines.append(f\"# {line.strip()}\")\n        # Check for numbered lists\n        elif re.match(r'^\\d+\\.\\s', line):\n            markdown_lines.append(line)\n        # Check for bullet points\n        elif line.strip().startswith('\u2022') or line.strip().startswith('*'):\n            markdown_lines.append(line)\n        else:\n            markdown_lines.append(line)\n    \n    # Join lines and write to file\n    markdown_text = '\\n'.join(markdown_lines)\n    \n    with open(output_path, 'w', encoding='utf-8') as f:\n        f.write(markdown_text)\n    \n    print(f\"Basic conversion complete. Markdown saved to {output_path}\")\n    return output_path\n\ndef format_markdown_with_prettier(markdown_path):\n    \"\"\"Format a Markdown file using Prettier\"\"\"\n    try:\n        # Check if prettier is installed\n        if not check_prettier_installation():\n            print(\"Prettier not found. Attempting to install...\")\n            if not install_prettier():\n                print(\"Could not install Prettier. Skipping formatting.\")\n                return markdown_path\n        \n        print(f\"Formatting {markdown_path} with Prettier...\")\n        \n        # Run prettier on the markdown file\n        result = subprocess.run(\n            ['npx', 'prettier', '--write', markdown_path],\n            capture_output=True,\n            text=True,\n            check=False\n        )\n        \n        if result.returncode == 0:\n            print(\"Formatting successful\")\n            return markdown_path\n        else:\n            print(f\"Prettier encountered an error: {result.stderr}\")\n            return markdown_path\n    except Exception as e:\n        print(f\"Error formatting Markdown with Prettier: {e}\")\n        return markdown_path\n\ndef pdf_to_markdown_workflow(pdf_path, output_path=None, format_with_prettier=True):\n    \"\"\"Complete workflow to convert PDF to formatted Markdown\"\"\"\n    if not os.path.exists(pdf_path):\n        print(f\"PDF file not found: {pdf_path}\")\n        return None\n    \n    if output_path is None:\n        output_path = os.path.splitext(pdf_path)[0] + '.md'\n    \n    # Try different conversion methods in order of preference\n    conversion_methods = [\n        (\"Pandoc\", lambda: pdf_to_markdown_with_pandoc(pdf_path, output_path)),\n        (\"PDFMiner\", lambda: pdf_to_markdown_with_pdfminer(pdf_path, output_path)),\n        (\"Basic PyPDF2\", lambda: pdf_to_markdown_basic(pdf_path, output_path))\n    ]\n    \n    markdown_path = None\n    for method_name, method_func in conversion_methods:\n        print(f\"\\nTrying conversion using {method_name}...\")\n        try:\n            result = method_func()\n            if result and os.path.exists(result):\n                markdown_path = result\n                print(f\"Successfully converted using {method_name}!\")\n                break\n            else:\n                print(f\"The {method_name} method did not produce a valid file.\")\n        except Exception as e:\n            print(f\"Error with {method_name} method: {e}\")\n    \n    if markdown_path is None:\n        print(\"All conversion methods failed.\")\n        return None\n    \n    # Format with prettier if requested\n    if format_with_prettier:\n        markdown_path = format_markdown_with_prettier(markdown_path)\n    \n    return markdown_path\n\ndef main():\n    # Set up argument parser\n    parser = argparse.ArgumentParser(description=\"Convert PDF to Markdown and format with Prettier\")\n    parser.add_argument(\"--file\", \"-f\", \n                      default=\"q-pdf-to-markdown.pdf\",\n                      help=\"Path to PDF file (default: q-pdf-to-markdown.pdf)\")\n    parser.add_argument(\"--output\", \"-o\", \n                      help=\"Output path for the Markdown file (default: same as input with .md extension)\")\n    parser.add_argument(\"--no-format\", action=\"store_true\", \n                      help=\"Skip formatting with Prettier\")\n    \n    # Parse arguments\n    args = parser.parse_args()\n    \n    print(f\"PDF to Markdown Conversion Tool - Starting with file: {args.file}\")\n    \n    # Check if file exists or try to find it\n    if not os.path.exists(args.file):\n        print(f\"File not found: {args.file}\")\n        \n        # Try looking in common locations\n        possible_locations = [\n            args.file,\n            os.path.join(os.getcwd(), args.file),\n            os.path.join(os.getcwd(), \"PDFs\", args.file),\n            os.path.join(os.getcwd(), \"data\", args.file),\n            os.path.join(\"E:\\\\data science tool\\\\GA4\", args.file)\n        ]\n        \n        found_file = False\n        for location in possible_locations:\n            if os.path.exists(location):\n                print(f\"Found PDF at: {location}\")\n                args.file = location\n                found_file = True\n                break\n        \n        if not found_file:\n            print(\"PDF file not found in any expected location.\")\n            print(\"Please place the PDF file in the correct location or specify the path with --file\")\n            sys.exit(1)\n    \n    # Run the conversion workflow\n    result = pdf_to_markdown_workflow(\n        args.file, \n        args.output, \n        format_with_prettier=not args.no_format\n    )\n    \n    if result:\n        print(\"\\n\" + \"=\"*50)\n        print(f\"Conversion completed successfully!\")\n        print(f\"Markdown file saved to: {result}\")\n        print(\"=\"*50)\n    else:\n        print(\"\\n\" + \"=\"*50)\n        print(\"Conversion failed. Please check the error messages above.\")\n        print(\"=\"*50)\n\nif __name__ == \"__main__\":\n    main()"
    }
]